# [Description](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/description/)

## Code

感觉就是[84题](<./84. 柱状图中最大的矩形.md>)的翻版，趁着下午刚被摧残过，立马写了一个翻版出来，结果 $68/73$，然后发现是好数组判断条件搞错了，通过

```cpp
class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        // 和找最大矩形那个题应该是一样的，只是更新答案的时候判断下是不是好数组
        nums.push_back(-1);
        int n = nums.size();

        std::stack<int> stk;
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            while (!stk.empty() && nums[i] <= nums[stk.top()]) {
                auto idx = stk.top();
                stk.pop();
                auto right = i;
                auto left = stk.empty() ? -1 : stk.top();
                // 注意left和right的定义
                if (left < k && right > k) {
                    ans = std::max(ans, nums[idx] * (right - left - 1));
                }
            }
            stk.push(i);
        }
        return ans;
    }
};
```

看了题解发现还有双指针做法，本质是一种贪心，可以双百

```cpp
class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        // 双指针，也是一种贪心
        // 从中间出发，每次取两侧的较大值，迈出一步，更新答案
        // 子数组最小值保证是单调递减的，长度保证是单调递增的
        int left = k, right = k;
        int n = nums.size();
        int ans = nums[k], curr_min = nums[k];
        for (int t = 0; t < n - 1; ++t) {
            if ((right == n - 1) || (left > 0 && nums[left - 1] > nums[right + 1])) {
                curr_min = std::min(curr_min, nums[--left]);
            } else {
                curr_min = std::min(curr_min, nums[++right]);
            }
            ans = std::max(ans, curr_min * (right - left + 1));
        }
        return ans;
    }
};
```

引用一段[评论区看到的思路](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/description/comments/2258171/)：

> 最大分数：ans = 子数组内最小值 *（right - left + 1）  
要求：必须包含nums[k]，那么找出的包含nums[k]的子数组的最小值一定 小于等于k，是递减的；那么能够贪的就是数组长度了，所以 针对每个子数组最小值寻找最大长度就成为贪心目标了。  
> 那么就以 下标为 k 为起始，同时向俩边寻找比nums[k]小的值，选择俩个值中的较大值作为新的子数据最小值，因为是子数据最小值从大到小递减的，所以数组长度是一直递增的，并且包含之前的数组。
