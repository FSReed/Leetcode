# [Description](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

放了一下完整的思考过程（未做出），体现了思维的重要性

## Code

先是15分钟没想出来好方法，暴力试试 $(15min)$

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 
        // 对于每个起点i，枚举终点j，计算其中所有可能的矩形
        // 遍历O(n), 枚举O(n)，计算过程找最小值要O(n)，复杂度O(n^3)
        int n = heights.size();
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            for (auto j = i; j < n; ++j) {
                int min_height = INT_MAX;
                for (auto k = i; k <= j; ++k) {
                    min_height = std::min(min_height, heights[k]);
                }
                ans = std::max(ans, (j - i + 1) * min_height);
            }
        }
        return ans;
    }
};
```

然后为了复用最小值，开了新的数组，导致MLE $(29min)$

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 区间最小值应该复用
        int n = heights.size();
        std::vector min_vals(n, std::vector<int>(n, INT_MAX));
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            auto i_min = INT_MAX;
            for (auto j = i; j < n; ++j) {
                auto &curr_min = min_vals[i][j];
                curr_min = std::min(i_min, heights[j]);
                i_min = curr_min;
            }
        }
        for (auto i = 0; i < n; ++i) {
            for (auto j = i; j < n; ++j) {
                auto min_height = min_vals[i][j];
                ans = std::max(ans, (j - i + 1) * min_height);
            }
        }
        return ans;
    }
};
```

然后意识到自己是个sb，计算过程中维护最小值就行了，现在通过样例 $90/99$ $(34min)$

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 计算过程中维护最小值就行了
        int n = heights.size();
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            auto curr_min = INT_MAX;
            for (auto j = i; j < n; ++j) {
                curr_min = std::min(curr_min, heights[j]);
                ans = std::max(ans, (j - i + 1) * curr_min);
            }
        }
        return ans;
    }
};
```

那么就是算法复杂度了，这里有哪些计算是多余的呢？记暴力循环中`(i, j)`循环内的计算结果为`f(i, j)`:

- 如果在一个区间[i, j]内，height一直单调递增，那么区间最小值永远不会更新，可以直接得到`f(i, j) = heights[i] * (j - i + 1)`; 单调递减也可以类似得到`f(i, j) = heights[j] * (j - i + 1)`
- ...

$40min$ ，歇逼了，看[题解](https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/2695467/dan-diao-zhan-fu-ti-dan-pythonjavacgojsr-89s7)吧  
草，起手思路就不一样，先确定最终矩形的高度值一定在`heights`数组中，否则面积一定还可以更大，然后枚举height，找每个height左右两侧最近的比height低的柱子的位置，如果在枚举过程中寻找，那时间复杂度还是 $O(N^2)$ ，但是这样拆解问题后可以用两次单调栈先计算出各个位置的左/右侧第一个比自己低的矩形位置，然后再枚举height，这样就是 $O(N)$ 了，太狠了  
于是自己先实现了一版，最后一次遍历还是很丑（注释里），观察了一下三元表达式的结构，改了数组初始化条件后，简洁了许多：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 思路太重要了，这思路真想不到啊
        int n = heights.size();
        std::vector<int> left(n, -1);
        // std::vector<int> right(n, -1);
        // 右端点初始化为 n
        std::vector<int> right(n, n);

        // 左边第一个更矮的
        std::stack<int> stk;
        for (auto i = n - 1; i >= 0; --i) {
            while (!stk.empty() && heights[i] < heights[stk.top()]) {
                left[stk.top()] = i;
                stk.pop();
            }
            stk.push(i);
        }
        
        while (!stk.empty()) stk.pop();
        
        // 右边第一个更矮的
        for (auto i = 0; i < n; ++i) {
            while (!stk.empty() && heights[i] < heights[stk.top()]) {
                right[stk.top()] = i;
                stk.pop();
            }
            stk.push(i);
        }

        // 找答案
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            // auto left_length = left[i] >= 0 ? i - left[i] - 1 : i;
            // auto right_length = right[i] >= 0 ? right[i] - i - 1 : n - i - 1;
            // auto area = heights[i] * (left_length + right_length + 1);
            // ans = std::max(ans, area);
            ans = std::max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
};
```

然后想到单调栈从左往右和从右往左遍历应该都可以求，那么可以用两个栈通过一次遍历求出左右两边的第一个更小高度，代码调整为总共两次遍历，但是是否需要两个独立的栈进行遍历呢？  
先选取一个遍历方向，写一下两次单调栈的遍历代码（本例采用从右到左）：

```cpp
...
std::stack<int> stk_l, stk_r;
for (auto i = n - 1; i >= 0; --i) {
    // 左边
    while (!stk_l.empty() && heights[i] < heights[stk_l.top()]) {
        left[stk_l.top()] = i;
        stk_l.pop();
    }
    stk_l.push(i);
    // 右边
    while (!stk_r.empty() && heights[i] <= heights[stk_r.top()]) {
        stk_r.pop();
    }
    if (!stk_r.empty()) right[i] = stk_r.top();
    stk_r.push(i);
}
...
```

- 可以发现只有出栈规则有一些区别，因为计算`right`数组时需要入栈的时候更新答案，所以只有判别到当前高度**严格小于**栈顶高度才会停止出栈，为了仅使用一个栈，是否可以将代码中的`<=`改为`<`呢？  
- 如果更改了，那么`right`数组的定义就发生了变化，变为下标`i`右侧第一个**小于或等于**其高度的柱子的下标，定义更改后，答案是否还能保证正确？**可以**。设想有两个同高度柱子（左边为 $L$ ，右边为 $R$ ）：
  - 如果 $L$ 和 $R$ 之间有高度更小的柱子，那么这个更改不会对结果产生影响，所以只考虑 $L$ 和 $R$ 之间没有高度更小的柱子的情况
  - 更改定义前，有`right[L] = right[R]`；更改定义后，有`right[L] = R`
  - 所以在最后遍历`height`的时候，左边的柱子计算结果会变小，但是右边的柱子不会受到影响，这其实可以说明最终的答案一定不会丢失

那么我们就可以用一个栈、一次遍历计算出`left`和`right`数组了：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        std::vector<int> left(n, -1);
        std::vector<int> right(n, n);

        std::stack<int> stk;
        for (auto i = n - 1; i >= 0; --i) {
            while (!stk.empty() && heights[i] < heights[stk.top()]) {
                left[stk.top()] = i;
                stk.pop();
            }
            if (!stk.empty()) right[i] = stk.top();
            stk.push(i);
        }

        // 找答案
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            ans = std::max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
};
```

题解里面最后提到了一个很牛逼的思路，只要一次遍历就完成，我个人体会了一下这种解法，此时并不是遍历height了，而是在单调栈计算过程中对每一个出栈的元素进行计算，最后如果栈内元素非空还需要手动把栈清空，自己体会了一下思路，写了这样的代码，基本圆满了：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        std::vector<int> left(n, -1);
        std::vector<int> right(n, n);

        std::stack<int> stk;
        int ans = 0;
        for (auto i = n - 1; i >= 0; --i) {
            while (!stk.empty() && heights[i] < heights[stk.top()]) {
                int idx = stk.top();
                left[idx] = i;    // 栈顶的left已经确定，栈顶的right就是它的下一个元素
                stk.pop();
                right[idx] = stk.empty() ? n : stk.top();
                ans = std::max(ans, heights[idx] * (right[idx] - left[idx] - 1));
            }
            stk.push(i);
        }
        // 如果栈里还剩下元素没有pop，那么还需要单独计算这些元素
        // 栈内底小顶大，left都是-1，right都是栈内下一个元素
        while (!stk.empty()) {
            int idx = stk.top();
            stk.pop();
            auto left = -1;
            auto right = stk.empty() ? n : stk.top();
            ans = std::max(ans, heights[idx] * (right - left - 1));
        }
        return ans;
    }
};
```

**还能优化**  

- 如果不想手动更新，其实可以在`for`循环最后再加一个`height = -1`的值，这样就可以把栈内所有元素都计算完毕；然而我这一路写下来是倒序遍历的，所以相当于要在height的开头加一个值-1
- 可以在栈底直接放一个高度为-1的元素，这样就不需要额外判断栈是否为空了。在我的代码中，这就相当于在height末尾放一个高度为-1的点
- 不再需要`left`和`right`数组了，因为栈顶元素出栈的时刻就可以同时获得left与right，而且这两个值后续也不会再被用到了

**还能优化**。目前来看，时间复杂度可以达到 $O(N)$ ，空间复杂度为 $O(N) $，然而栈内**可能有重复元素**，所以改写成正序遍历后，栈内可以无重复元素，空间复杂度可以进一步下降，尤其在重复元素多的情况下，贴一下自己改写后的代码：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 在最后放一个-1用于清空栈
        heights.push_back(-1);
        int n = heights.size();

        std::stack<int> stk;
        int ans = 0;
        for (auto i = 0; i < n; ++i) {
            while (!stk.empty() && heights[i] <= heights[stk.top()]) {
                auto idx = stk.top();
                auto right = i; // 栈顶元素的right已经找到了
                stk.pop();
                auto left = stk.empty() ? -1 : stk.top();
                ans = std::max(ans, heights[idx] * (right - left - 1));
            }
            stk.push(i);
        }
        return ans;
    }
};
```

圆满了，我很开心
