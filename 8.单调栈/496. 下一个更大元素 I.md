# [Description](https://leetcode.cn/problems/next-greater-element-i/description/)

## Code

最基础的单调栈，但是写起来还不是很熟练

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 摆明了是单调栈
        // 可以建一个数组，用于记录nums1里面数字的下标
        int m = nums1.size();
        int n = nums2.size();
        std::vector<int> answer(m, -1);
        std::vector<int> idx(1e4 + 1, -1);

        for (auto i = 0; i < m; ++i) {
            idx[nums1[i]] = i;
        }

        // 从左往右
        std::stack<int> stk;
        for (auto i = 0; i < n; ++i) {
            // while (!stk.empty() && nums2[i] > nums2[stk.top()]) {
            //     auto curr_idx = stk.top();
            //     stk.pop();
            //     if (idx[nums2[curr_idx]] >= 0) {
            //         // 更新答案
            //         answer[idx[nums2[curr_idx]]] = nums2[i];
            //     }
            // }
            // stk.push(i);
            while (!stk.empty() && nums2[i] > nums2[stk.top()]) {
                // 栈内元素全在nums1中，直接更新
                answer[idx[nums2[stk.top()]]] = nums2[i];
                stk.pop();
            }
            if (idx[nums2[i]] >= 0) {
                // 当前元素在nums1中，入栈
                stk.push(i);
            }
        }
        return answer;
    }
};
```

这样写没问题，不过看了[题解](https://leetcode.cn/problems/next-greater-element-i/solutions/2820648/shi-pin-dan-diao-zhan-de-liang-chong-xie-ri0i)后发现还有优化的空间。因为我们只需要记录在`nums1`中出现过的数字，所以在入栈的时候可以做一下筛选，如果当前遍历到的元素不在`nums1`中，那么它后续即使被出栈也不会过更新答案，所以不入栈。这样做也不会导致单调栈做法错误，因为当前是从左向右遍历，每一个遇到的“最大值”都只起到一个类似“屏障”的作用，也就是每遇到一次比栈顶元素大的，就会尝试更新答案，更新结束后，这个最大值如果不在`nums1`中，那么它再也不会被用到了，所以不入栈是合理的（从右往左就不行，需要老老实实入栈）。这个更新已经体现在上面的代码中了  
再写一个从右向左的：

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 摆明了是单调栈
        // 可以建一个数组，用于记录nums1里面数字的下标
        int m = nums1.size();
        int n = nums2.size();
        std::vector<int> answer(m, -1);
        std::vector<int> idx(1e4 + 1, -1);

        for (auto i = 0; i < m; ++i) {
            idx[nums1[i]] = i;
        }

        // 从右向左
        std::stack<int> stk;
        for (auto i = n - 1; i >= 0; --i) {
            while (!stk.empty() && nums2[i] > nums2[stk.top()]) {
                // 右侧元素不需要了
                stk.pop();
            }
            if (idx[nums2[i]] >= 0) {
                // 入栈，更新答案
                answer[idx[nums2[i]]] = stk.empty() ? -1 : nums2[stk.top()];
            }
            stk.push(i);
        }
        return answer;
    }
};
```
