# [Description](https://leetcode.cn/problems/maximal-rectangle/description/)

## Code

转化成[84题](<./84. 柱状图中最大的矩形.md`>)还是花了一些时间，但是84题印象十分深刻，写出来倒是很快，结果竟然有一个全1的测试样例卡住了

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        // 每一行为底找一个最大包络矩形？
        int m = matrix.size();
        int n = matrix[0].size();
        std::vector<char> pre(n, 0);
        for (auto i = 0; i < m; ++i) {
            for (auto j = 0; j < n; ++j) {
                matrix[i][j] = matrix[i][j] == '0' ? 0 : pre[j] + 1;
                pre[j] = matrix[i][j];
            }
        }

        std::stack<int> stk;
        int ans = 0;
        for (auto i = 0; i < m; ++i) {
            stk = std::stack<int>();
            matrix[i].push_back(-1);
            for (auto j = 0; j <= n; ++j) {
                while (!stk.empty() && matrix[i][j] <= matrix[i][stk.top()]) {
                    auto idx = stk.top();
                    stk.pop();
                    auto left = stk.empty() ? -1 : stk.top();
                    ans = std::max(ans, matrix[i][idx] * (j - left - 1));
                }
                stk.push(j);
            }
        }
        return ans;
    }
};
```

是真的恶心人，因为`matrix`数组本身是char类型，所以最多存储-128到127，而最后一个样例是`200*200`的全1矩阵，所以报错了。本来输入格式是char就够恶心了，还这样被卡，无语  
收获是后来发现不需要新建一个矩阵，这个题和动态规划非常像，计算完一行的数据之后，这一行就再也用不到了，所以只需要维护储存相应列位置的柱高的一维数组，遍历的时候动态更新就行了

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        // 每一行为底找一个最大包络矩形？
        int m = matrix.size();
        int n = matrix[0].size();
        std::vector<int> pre(n + 1, 0);

        std::stack<int> stk;
        int ans = 0;
        for (auto i = 0; i < m; ++i) {
            stk = std::stack<int>();
            for (auto j = 0; j <= n; ++j) {
                int height = j == n ? -1 : (matrix[i][j] == '0' ? 0 : pre[j] + 1);
                pre[j] = height;
                while (!stk.empty() && height <= pre[stk.top()]) {
                    auto idx = stk.top();
                    stk.pop();
                    auto left = stk.empty() ? -1 : stk.top();
                    ans = std::max(ans, pre[idx] * (j - left - 1));
                }
                stk.push(j);
            }
        }
        return ans;
    }
};
```
