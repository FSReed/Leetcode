# [Description](https://leetcode.cn/problems/trapping-rain-water/description/)

## Code

看完视频自信满满，上手写代码像个小儿麻痹，写得又臭又长，循环内更新逻辑、pop逻辑一团浆糊，调了45分钟才跑过，甚至过程中还有可能把左墙也给pop了再补回去，当时最后加上这个if判断真给我气笑了  
更别说接雨水是在第一章节[相向双指针](<../1.相向双指针/42 接雨水.md>)就做过的，心态崩了  

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        // 石山
        int n = height.size();
        int ans = 0;
        std::stack<int> stk;
        for (int i = 0; i < n; ++i) {
            int bottom_idx = -1;
            if (!stk.empty() && height[i] > height[stk.top()]) {
                bottom_idx = stk.top();
                stk.pop();
            }
            if (bottom_idx >= 0 && !stk.empty()) {
                // 有水
                while (!stk.empty() && height[i] >= height[bottom_idx]) {
                    int left_idx = stk.top();
                    auto left_height = height[left_idx];
                    ans += (std::min(left_height, height[i]) - height[bottom_idx]) * (i - left_idx - 1);
                    // std::cout << "ans = " << ans << '\n';
                    bottom_idx = left_idx;
                    stk.pop();
                }
                // 甚至还有可能把墙也给pop了，当时最后加上这个if判断真给我气笑了
                if (height[i] < height[bottom_idx]) {
                    stk.push(bottom_idx);
                }
            }
            stk.push(i);
            // std::cout << "After " << i << ": " << stk.size() << '\n';
        }
        return ans;
    }
};
```

费劲的原因在于无意义的分类讨论，实际上应该贯彻一点：**只要右墙比左墙高，那就有可能是一个凹槽**，至于是不是凹槽，在循环内部进行判断。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        // 单调栈写法
        int n = height.size();
        int ans = 0;
        std::stack<int> stk;
        for (int i = 0; i < n; ++i) {
            // 不要一个个桶去做模拟，要转换视角，“横着”去填充一个可能的凹槽
            // **只要**右墙比左墙高（或者一样高），这就可能是一个水槽，至于是不是，循环里面去判断
            while (!stk.empty() && height[i] >= height[stk.top()]) {
                int bottom_idx = stk.top();
                stk.pop();
                if (stk.empty()) {
                    // 没有左墙，不是一个凹槽，可以结束了
                    break;
                }
                int left_idx = stk.top();
                ans += (std::min(height[left_idx], height[i]) - height[bottom_idx]) * (i - left_idx - 1);
            }
            stk.push(i);
        }
        return ans;
    }
};
```
