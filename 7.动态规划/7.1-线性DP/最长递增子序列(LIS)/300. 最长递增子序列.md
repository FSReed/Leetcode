# [Description](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

## Code

一个简单的想法是回溯，枚举所有的递增子序列然后选出长度最长的，时间复杂度$O(N^2)$，能过就是了

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 回溯找到所有严格递增子序列，采用“选哪个”的方式
        std::vector<int> results(nums.size(), 0);
        std::function<int(int)> dfs = [&](int i) -> int {
            if (results[i] > 0) {
                return results[i];
            }
            int ans = 1;
            for (auto j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    ans = std::max(ans, dfs(j) + 1);
                }
            }
            results[i] = ans;
            return ans;
        };
        int ans = 0;
        for (auto i = 0; i < nums.size(); ++i) {
            ans = std::max(ans, dfs(i));
        }
        return ans;
    }
};
```

如何优化呢？这次视频中提到了一个DP问题中的进阶技巧：**交换状态与状态值**。对于这道题，回溯的状态是元素的位置，状态值是每个位置元素的最长LIS长度，交换一下就变成：**状态是一个给定的LIS长度，状态值是这个长度的序列的末尾元素的最小值**  
这是怎么想到的？翻了下评论区，发现了这样一条理解：

> 原因在于，这是一个求【递增】子序列的题目，如果能通过巧妙地定义状态，构造出一个递增的东西，就可以利用二分算法优化了

另外还有数论理论支持：

> 贪心的做法背后是数论，dilworth 定理：偏序集能划分成的最少的全序集个数等于最大反链的元素个数。应用到LIS问题上就是，你要求最长严格上升子序列的长度，等于去划分不下降子序列，最少划分出多少条。

理论先不深究了，回到这个题目上，上面描述的数组（记为`g`)有一些性质：

1. `g`一定是单调递增的
2. 遍历`nums`的过程中，被遍历到的每个元素只会更新`g`中的一个位置，否则就违背了性质1
3. 更新的位置一定是`g`中第一个`>=nums[i]`的位置(记为`pos`)。如果更新位置更靠后(记为`pos_after`)，显然违背了性质1，因为更新后会有`g[pos_after] <= g[pos]`；如果更新位置更靠前(记为`pos_before`)，那么`g[pos_before]`位置的值变大了，`g[pos_before]`的值并不是长度为`pos_before + 1`的LIS的末尾元素的最小值，也不对

基于以上考虑，每次查找`g`中第一个`>=num[i]`的位置并且更新就可以(如果`nums[i]`比g中所有元素大，就把`nums[i]`插入到`g`中)，这就是二分查找的舒适区了，时间复杂度只有$O(NlogN)$，很顶

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 转化为贪心 + 二分查找问题
        // 数组下标为(LIS的长度 - 1)，值为满足要求的LIS序列最后一个数的最小值
        std::vector<int> g;
        for (auto i = 0; i < nums.size(); ++i) {
            // 尝试更新g数组
            // 每次更新的位置一定是第一个>=nums[i]的位置
            auto pos = std::lower_bound(g.begin(), g.end(), nums[i]);
            if (pos == g.end()) {
                g.push_back(nums[i]);
            } else {
                *pos = nums[i];
            }
        }
        return g.size();
    }
};
```
