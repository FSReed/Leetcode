# [Description](https://leetcode.cn/problems/russian-doll-envelopes/description/)

## Code

这个题想到对一个维度先排序，然后寻找第二个维度的LIS的思路并不难想，但是在处理第一个维度的相同值时候遇到了困难，调了半天也没调出来，眼看着代码快要被if-else堆成石山了，去看了题解，发现可以在排序的时候就把同一个宽度的信封按照高度从大到小排序，这样后面寻找LIS的时候，同一个宽度的信封只会找到一个了

```cpp
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        // 先按照一个维度进行排序，然后从这个维度中找LIS
        auto compare = [](vector<int> &a, vector<int> &b) -> bool {
            if (a[0] != b[0]) { return a[0] < b[0]; }
            return a[1] > b[1];
        };

        std::sort(envelopes.begin(), envelopes.end(), compare);

        // 寻找信封高度的LIS
        // 由于前面对于相同宽度，将高度从大到小进行了排序，同一个宽度的信封只会选择一个
        std::vector<int> g;
        for (auto i = 0; i < envelopes.size(); ++i) {
            int height = envelopes[i][1];
            auto pos = std::lower_bound(g.begin(), g.end(), height);
            if (pos == g.end()) {
                g.push_back(height);
            } else {
                *pos = height;
            }
        }
        return g.size();
    }
};
```
