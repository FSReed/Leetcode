# [Description](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/description/)

## Code

一路写到这，第一个很自然的想法就是：每个下标我都去找一下前面的LIS以及后面的LDS，最后在所有下标中取一个操作数的最小值，时间复杂度是$O(N^2logN)$的

```cpp
class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) {
        // 第一个想到的笨方法，对于每个下标，计算左边递增右边递减的删除次数，找最小的
        int n = nums.size();
        int prev_min = INT_MAX;
        for (auto i = 1; i < n - 1; ++i) {
            prev_min = std::min(prev_min, minOperation(nums, i));
            std::cout << prev_min << std::endl;
        }
        return prev_min;
    }
private:
    int minOperation(vector<int> &nums, int m) {
        std::vector<int> g1, g2;
        for (auto i = 0; i <= m; ++i) {
            auto pos = std::lower_bound(g1.begin(), g1.end(), nums[i]);
            if (pos == g1.end()) {
                g1.push_back(nums[i]);
            } else {
                *pos = nums[i];
            }
        }
        for (auto j = nums.size() - 1; j >= m; --j) {
            auto pos = std::lower_bound(g2.begin(), g2.end(), nums[j]);
            if (pos == g2.end()) {
                g2.push_back(nums[j]);
            } else {
                *pos = nums[j];
            }
        }
        if (g1.size() == 1 || g2.size() == 1) {
            return INT_MAX;
        }
        return nums.size() + 1 - g1.size() - g2.size();
    }
};
```

能过，但是仔细看看，**代码逻辑是错误的**。在上面的这版实现中，每一个下标所检索的前半部分最长递增子序列并不保证是以当下下标作为最后一个元素的！  

> 举个例子，数组`[1, 2, 3, 2, 1]`遍历到下标`i = 3`，也即`nums[i] = 2`的时候，前半部分的LIS是`[1, 2, 3]`，并不是以`nums[3] = 2`作为最后一个元素。后半部分的LDS是`[2, 1]`  

那为什么结果是对的？因为这个方法是个笨方法，对于一个下标`m`，假设下标从`0`到`m`之间的最长递增子序列末尾元素是`nums[n1]`，那么一定有`nums[n1] >= nums[m]`，也就是在遍历到下标`m`之前，已经遍历过`n1`，而且遍历到`n1`的LDS中虽然不一定包含`m`，但是一定检查过`nums[m]`是否符合条件，换句话说，遍历`m`得到的LIS与LDS，不会比遍历`n1`时得到的结果更长，遍历`m`的这次操作完全是多余的。  
结合这种想法，再去看了下题解中提到的**前后缀分解**就比较说得通了：先从前往后遍历一遍`nums`，对于没一个下标`i`，都记录一下以`num[i]`为末尾元素的LIS长度(*前缀数组*)，这一点可以在更新`g`数组之前实现（详见代码， 其实就是通过二分查找得到的在`g`中的插入位置来确定LIS长度）；再从后往前遍历一遍`nums`，这一次记录以每个`nums[i]`为开头的LDS的长度(*后缀数组*)，最后通过这两个数组去寻找最小值就行了。时间复杂度$O(NlogN)$

> 在第二次遍历的过程中就可以记录答案了，避免一次多余的遍历寻找最小值的过程

```cpp
class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) {
        // 正确实现
        int n = nums.size();
        std::vector<int> pre(n, 1), g;
        for (auto i = 0; i < n; ++i) {
            auto pos = std::lower_bound(g.begin(), g.end(), nums[i]);
            pre[i] = pos - g.begin() + 1;
            if (pos == g.end()) {
                g.push_back(nums[i]);
            } else {
                *pos = nums[i];
            }
        }

        g.clear();
        int prev_min = INT_MAX;
        for (auto j = n - 1; j >= 0; --j) {
            auto pos = std::lower_bound(g.begin(), g.end(), nums[j]);
            int tmp_suf = pos - g.begin() + 1;
            if (tmp_suf != 1 && pre[j] != 1) {
                prev_min = std::min(prev_min, n + 1 - tmp_suf - pre[j]);
            }
            if (pos == g.end()) {
                g.push_back(nums[j]);
            } else {
                *pos = nums[j];
            }
        }
        return prev_min;
    }
};
```
