# 笔记

## 记忆化搜索 -> 递推翻译过程中的边界处理

研究的契机是[72题目](./72.%20编辑距离.md)以及[97题](./97.%20交错字符串.md)中反复折磨我的递推初始化。在看了一些题解以及评论之后，明确了需要将**记忆化搜索的边界**翻译为**递推的初始化**。下面以97题为例进行说明，记忆化搜索的写法如下：

```cpp
std::function<bool(int, int)> dfs = [&](int i, int j) -> int {
    if (i < 0 && j < 0) {
        return true;
    }
    return i >= 0 && s1[i] == s3[i + j + 1] && dfs[i - 1][j] ||
           j >= 0 && s2[j] == s3[i + j + 1] && dfs[i][j - 1];
};
```

在下面的讨论中，记递推方法的数组为`result[s1.size()][s2.size()]`

1. 这里的递归边界是`i < 0 && j < 0`，翻译为递推后即为`result[0][0] = true`
2. **关键在于迭代中的初始化**：
   - 如果`j < 0`，那么看记忆化搜索`return`语句的第一行，需要将`result[i + 1][0]`初始化为`s1[i] == s3[i + j + 1] && dfs[i - 1][j]`，也就是`result[i + 1][0] = s1[i] == s3[i + j + 1] && result[i][0]`
   - 那如何翻译第二行呢？答案是在进入dp之前将**`result[0][j + 1]`**全部初始化：

   ```cpp
   for (int j = 0; j < s2.size(); j++) {
        result[0][j + 1] = s2[j] == s3[j] && result[0][j];
    }
   ```

3. 为什么需要初始化，而不能在dp循环中进行更新？引用灵神在评论区里的原话：

   > 不从其他状态转移的状态，就是初始值。如果还需要继续递归的状态就不是初始值

   在本题中，`i < 0`与`j < 0`两个状态不是由其他状态转移来的，所以需要将它们对应的状态进行初始化

妙啊:cry:
