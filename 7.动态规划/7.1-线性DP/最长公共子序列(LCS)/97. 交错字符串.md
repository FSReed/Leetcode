# [Description](https://leetcode.cn/problems/interleaving-string/description/)

## Code

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // 如果s1[i]或s2[j] != s3[i + j + 1]则不能组成s3
        // 反之：s1[i] == s3[i + j + 1]，则result[i][j] = result[i - 1][j]
        //      s2[j] == s3[i + j + 1]， 则result[i][j] = result[i][j - 1]
        int n1 = s1.size(), n2 = s2.size();
        if (n1 + n2 != s3.size()) { return false; }

        std::vector<bool> result(n2 + 1, false);
        result[0] = true;
        for (auto i = 0; i < n2; ++i) {
            // 考虑s1为空
            result[i + 1] = result[i] && s2[i] == s3[i];
        }

        for (auto i = 0; i < n1; ++i) {
            // 这行初始化真给我整麻了
            result[0] = result[0] && s1[i] == s3[i];
            for (auto j = 0; j < n2; ++j) {
                if (s1[i] != s3[i + j + 1] && s2[j] != s3[i + j + 1]) {
                    result[j + 1] = false;
                } else {
                    result[j + 1] = s1[i] == s3[i + j + 1] && result[j + 1] ||
                                    s2[j] == s3[i + j + 1] && result[j];
                }
            }
        }
        return result[n2];
    }
};
```

后来看了一下[题解](https://leetcode.cn/problems/interleaving-string/solutions/3060419/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-qcen)，评论区中也有不少人提到了递推写法中怎么把边界也翻译过来，灵神给的回复是从记忆化搜索的边界翻译过来。于是回去看了下记忆化搜索过程，`dfs(i, j)`的返回边界是`(i < 0 && j < 0)`，此时返回`true`. 翻译到递推就是`f[0][0] = true`。但是`f[i + 1][0] = f[i] && s1[i] == s3[i]`是怎么翻译出来的呢？  
总结于本目录下的[README](./README.md)，可以去看一下
