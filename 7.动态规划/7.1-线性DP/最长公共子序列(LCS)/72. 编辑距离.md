# [Description](https://leetcode.cn/problems/edit-distance/description/)

## Code

原本是hard，不知道为啥现在成了mid，他妈的，写不了一点  
写状态转移方程就没写出来，按照刚写完1143题的劲头直接翻译成一维数组，发现根本不知道怎么初始化：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        std::vector<int> f(m + 1, 0);

        for (int i = 0; i < n; i++) {
            int prev = f[0];
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1];
                // 翻译状态转移方程；
                if (word1[i] == word2[j]) {
                    f[j + 1] = prev;
                } else {
                    f[j + 1] = std::min({f[j + 1], f[j], prev}) + 1;
                }
                prev = tmp;
            }
        }
        return f[m];
    }
};
```

再去看题解，原来当一个字符串的长度到达0的时候，就说明至少需要`另一个字符串长度`的次数才能让两个字符串相同(也就是把另一个字符串都删光)，于是就有了这题特殊的初始化：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        std::vector<int> f(m + 1);
        // 初始化i = 0时的f[j]值
        for (int j = 0; j <= m; j++) {
            f[j] = j;
        }

        for (int i = 0; i < n; i++) {
            int prev = f[0];
            // 初始化f(i + 1, 0)
            f[0] = i + 1;
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1];
                // 翻译状态转移方程；
                if (word1[i] == word2[j]) {
                    f[j + 1] = prev;
                } else {
                    f[j + 1] = std::min({f[j + 1], f[j], prev}) + 1;
                }
                prev = tmp;
            }
        }
        return f[m];
    }
};
```

说真的，跑通了还是觉得有点模模糊糊的

## 后续重刷记录

- 2025/10/12: 写dp迭代十分钟以内就结束了，但是这题初始化真的难想，考虑`word1`为空需要初始化，每一轮迭代还需要进行初始化：

   ```cpp
    class Solution {
    public:
        int minDistance(string word1, string word2) {
            int n2 = word2.size();
            std::vector result(n2 + 1, 0);
            // 下面这些初始化是考虑了word1为空的情况
            for (auto i = 0; i <= n2; ++i) {
                result[i] = i;
            }

            for (int i = 0; i < word1.size(); ++i) {
                int pre = result[0];    // 上一轮的更新结果result[i][j]
                result[0] = i + 1;      // 本轮的更新结果result[i + 1][j]
                for (int j = 0; j < word2.size(); ++j) {
                    int snapshot = result[j + 1];
                    if (word1[i] == word2[j]) {
                        result[j + 1] = pre;
                    } else {
                        // 等式右半边的result[j + 1]是上一轮的结果result[i][j + 1]
                        result[j + 1] = std::min({result[j], result[j + 1], pre}) + 1;
                    }
                    pre = snapshot;
                }
            }
            return result[n2];
        }
    };
   ```
