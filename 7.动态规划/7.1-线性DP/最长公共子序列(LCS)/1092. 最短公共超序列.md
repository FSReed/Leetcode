# [Description](https://leetcode.cn/problems/shortest-common-supersequence/description/)

## Code

纯手搓，转化为找两个字符串的最长公共子序列这一步不是自己想到的，剩下的就是实现细节，自己手搓了一版，感觉写过445之后对于这种大量实现细节的问题不那么害怕了。  

- 写完记忆化搜索后，共用时55min，跑通了47个测试，剩余测试有超出内存限制的，需要优化内存占用

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        // 转化为找str1，str2的最长公共子序列，不过这次需要附带子序列的下标信息
        // 如果str1[i] == str2[j]: dfs(i + 1, j + 1).count = dfs(i, j).count + 1
        // dfs(i + 1, j + 1).idx_1 = dfs(i, j).idx_1.push_back(i)
        // dfs(i + 1, j + 1).idx_2 = dfs(i, j).idx_2.push_back(j)
        // 如果不等于，那就选两种情况
        // dfs(i + 1, j + 1).count = max(dfs(i, j + 1).count, dfs(i + 1, j).count)
        // 分别再更新
        int m = str1.size(), n = str2.size();
        std::vector records(m, std::vector<Result>(n, {-1, {}, {}}));
        std::function<Result(int, int)> dfs = [&](int i, int j) {
            if (i < 0 || j < 0) {
                // 到头了
                return Result();
            }
            if (records[i][j].count >= 0) {
                return records[i][j];
            }
            if (str1[i] == str2[j]) {
                auto prev_result = dfs(i - 1, j - 1);
                Result new_result{};
                new_result.Update(prev_result, i, j);
                records[i][j] = new_result;
                return new_result;
            }
            auto res_1 = dfs(i - 1, j);
            auto res_2 = dfs(i, j - 1);
            auto result = res_1.count >= res_2.count ? res_1 : res_2;
            records[i][j] = result;
            return result;
        };
        
        auto result = dfs(m - 1, n - 1);
        // result里面有最长公共子序列和对应的下标
        return ConcatenateString(result.idx_1, result.idx_2, str1, str2);
    }
private:
    class Result {
    public:
        int count{0};
        std::vector<int> idx_1{};
        std::vector<int> idx_2{};
        void Update(Result &other, int i, int j) {
            this->count = other.count + 1;
            this->idx_1 = other.idx_1;
            this->idx_2 = other.idx_2;
            this->idx_1.push_back(i);
            this->idx_2.push_back(j);
        }
    };
    auto ConcatenateString(std::vector<int> &idx1, std::vector<int> &idx2,
                           std::string &str1, std::string &str2) -> std::string {
        
        std::stringstream ss;
        int prev_i = 0, prev_j = 0;
        int pos = 0;
        while (prev_i < str1.size() || prev_j < str2.size()) {
            int upper_i = pos >= idx1.size() ? str1.size() : idx1[pos];
            int upper_j = pos >= idx2.size() ? str2.size() : idx2[pos];
            for (auto i = prev_i; i < upper_i; ++i) {
                ss << str1[i];
            }
            for (auto j = prev_j; j < upper_j; ++j) {
                ss << str2[j];
            }
            prev_i = upper_i;
            prev_j = upper_j;
            if (pos >= idx1.size()) { break; }
            ss << str1[idx1[pos]];
            ++prev_i;
            ++prev_j;
            ++pos;

        }
        return ss.str();
    }
};
```

- 时间来到1h20min, 翻译成递推并且优化成一维数组，结果还是超出空间限制，给我整不会了，看来这种存下标的方法不合适(仍然是47/50)

```cpp
string shortestCommonSupersequence(string str1, string str2) {
        // 转化为找str1，str2的最长公共子序列，不过这次需要附带子序列的下标信息
        // 如果str1[i] == str2[j]: dfs(i + 1, j + 1).count = dfs(i, j).count + 1
        // dfs(i + 1, j + 1).idx_1 = dfs(i, j).idx_1.push_back(i)
        // dfs(i + 1, j + 1).idx_2 = dfs(i, j).idx_2.push_back(j)
        // 如果不等于，那就选两种情况
        // dfs(i + 1, j + 1).count = max(dfs(i, j + 1).count, dfs(i + 1, j).count)
        // 分别再更新
        int m = str1.size(), n = str2.size();
        std::vector<Result> records(n + 1);
        for (int i = 0; i < m; ++i) {
            auto prev_result = records[0];
            for (int j = 0; j < n; ++j) {
                auto tmp = records[j + 1];
                if (str1[i] == str2[j]) {
                    Result new_result{};
                    new_result.Update(prev_result, i, j);
                    records[j + 1] = new_result;
                } else {
                    auto res_1 = records[j];
                    auto res_2 = records[j + 1];
                    auto result = res_1.count >= res_2.count ? res_1 : res_2;
                    records[j + 1] = result;
                }
                prev_result = tmp;
            }
        }
        auto result = records[n];
        // result里面有最长公共子序列对应的下标
        return ConcatenateString(result.idx_1, result.idx_2, str1, str2);
    }
```

- 隔天，看了先构造LCS再生成结果的题解，发现可以利用二维dp数组的结果反向构造答案，不用在过程中储存下标（多余信息），于是重新写了一版，终于过了：

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        // 转化为找str1，str2的最长公共子序列，不过这次需要附带子序列的下标信息
        // 如果str1[i] == str2[j]: dfs(i + 1, j + 1).count = dfs(i, j).count + 1
        // dfs(i + 1, j + 1).idx_1 = dfs(i, j).idx_1.push_back(i)
        // dfs(i + 1, j + 1).idx_2 = dfs(i, j).idx_2.push_back(j)
        // 如果不等于，那就选两种情况
        // dfs(i + 1, j + 1).count = max(dfs(i, j + 1).count, dfs(i + 1, j).count)
        // 分别再更新
        int m = str1.size(), n = str2.size();
        std::vector records(m + 1, std::vector<int>(n + 1, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (str1[i] == str2[j]) {
                    records[i + 1][j + 1] = records[i][j] + 1;
                } else {
                    auto res_1 = records[i + 1][j];
                    auto res_2 = records[i][j + 1];
                    records[i + 1][j + 1] = res_1 >= res_2 ? res_1 : res_2;
                }
            }
        }
        auto result = records[m][n];
        // result里面有最长公共子序列对应的下标
        return GenerateString(records, str1, str2);
    }
private:
    auto GenerateString(std::vector<std::vector<int>> &records, std::string &str1, std::string &str2) -> std::string {
        std::stringstream ss;
        int i = str1.size(), j = str2.size();
        while (i > 0 || j > 0) {
            if (i == 0) {
                ss << str2[j - 1];
                --j;
            } else if (j == 0) {
                ss << str1[i - 1];
                --i;
            } else if (str1[i - 1] == str2[j - 1] && records[i][j] == records[i - 1][j] + 1) {
                // LCS中的公共字符
                ss << str1[i - 1];
                --i;
                --j;
            } else if (records[i][j] == records[i - 1][j]) {
                ss << str1[i - 1];
                --i;
            } else if (records[i][j] == records[i][j - 1]) {
                ss << str2[j - 1];
                --j;
            }
            // std::cout << ss.str() << ": " << i << " " << j << std::endl;
        }
        auto result = ss.str();
        std::reverse(result.begin(), result.end());
        return result;
    }
};
```

时间复杂度为$O(M * N)$，空间复杂度亦是
