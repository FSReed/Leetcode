# [Description](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/description/)

## Code

上来先不管不顾写了一版返回最大价值和最小价值的dfs，墨迹半天写了个 $O(n^2)$ 的，结果虽然对了，但是美美超时

```cpp
class Solution {
public:
    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {
        // 感觉dfs返回最大，最小就可以？试试
        std::vector<std::vector<int>> tree(n);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        int ans = 0;
        auto dfs = [&](auto &&dfs, int node, int fa) -> std::pair<int, int> {
            int max_val = price[node], min_val = price[node];
            for (auto &child : tree[node]) {
                if (child != fa) {
                    auto [curr_max, curr_min] = dfs(dfs, child, node);
                    max_val = std::max(max_val, curr_max + price[node]);
                    min_val = std::min(min_val, curr_min + price[node]);
                }
            }
            return {max_val, min_val};
        };
        for (int i = 0; i < n; ++i) {
            auto [max_val, min_val] = dfs(dfs, i, -1);
            ans = std::max(ans, max_val - min_val);
        }
        return ans;
    }
};
```

看数据量`n <= 10^5`，$O(n^2)$ 肯定超时，而且肉眼可见这种方法存在许多的多余运算，怎么优化呢？  
想不出来，无奈，看[题解](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/solutions/2062782/by-endlesscheng-5l70)吧，结果题解也看了半天才看懂在说什么，总结的话，还是要先通过理论推导将问题转化为熟悉的形式  
我上面的思路是被题目要求限制了，题目要求**以根节点为起点**的路径，我想当然地先定死根节点，在此基础上进行dp，那遍历所有节点重复dfs就是无法避免的。实际上仔细看看样例，就会发现一个节点为起点的最小价值路径**一定只包含这个节点本身**，所以`最大价值 - 最小价值`就是**一条少了一个节点的路径的价值之和**  
在此基础上，由于节点价值全都是正数，所以这种路径一定是去掉一个叶子节点的路径，最终问题就转化成**去掉一个叶子节点的路径的最大价值**。现在问题已经变得很熟悉了，就是树上最大路径和问题的变形，不过为了解决这个问题，还需要修改一下实现思路。每次dfs一个节点，仍然需要返回两个值：

1. 该节点为起点不含叶子节点的路径最大价值(`v1`)
2. 该节点为起点含叶子节点的路径最大价值(`v2`)

首先dfs该节点（父节点）的所有子节点，每个子节点都返回上面的这两种值，每次dfs一个子节点后，首先更新答案，然后更新父节点的两个值。答案更新方法是：

1. 父节点之前的`v1` + 子节点`v2` + 父节点value
2. 父节点之前的`v2` + 子节点`v1` + 父节点value

最后一点就是dfs中返回值的初始化，恶心死我了，经常有`初始化值`, `循环内更新逻辑`, `return返回值`互相影响的情况，个人体会我写在注释里了，感觉是先要确定合理的返回值，然后根据边界条件初始化，然后再写更新逻辑，玄学，以后多写多体会吧

```cpp
class Solution {
public:
    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {
        // 感觉dfs返回最大，最小就可以？试试
        std::vector<std::vector<int>> tree(n);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        int ans = 0;
        auto dfs = [&](auto &&dfs, int node, int fa) -> std::pair<int, int> {
            // int w_leaf = ?, wo_leaf = ?;
            // 初始化恶心死我了，个人经验是不如确定好这样的框架，然后根据不进循环情况下的返回值进行初始化
            // 比如这里不进循环说明是叶子节点，返回{price[node], 0}
            // 据此进行初始化
            // 然后就会发现循环里面的更新逻辑是根据return语句决定的，所以这里w_leaf和wo_leaf都表示**包括了父节点的**路径，据此进行循环内更新
            for (auto &child : tree[node]) {
                if (child != fa) {
                    auto [leaf, no_leaf] = dfs(dfs, child, node);
                    ans = std::max(ans, std::max(leaf + wo_leaf, no_leaf + w_leaf));
                    w_leaf = std::max(w_leaf, leaf + price[node]);
                    wo_leaf = std::max(wo_leaf, no_leaf + price[node]);
                }
            }
            return {w_leaf, wo_leaf};
        };
        dfs(dfs, 0, -1);
        return ans;
    }
};
```
