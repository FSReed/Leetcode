# [Description](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/description/)

## Code

自己硬写了一版，踉踉跄跄写完好歹是跑过了，一看执行用时超过了5%的人绷不住了

```cpp
class Solution {
public:
    int ans = INT_MIN;
    int longestPath(vector<int>& parent, string s) {
        int n = parent.size();
        std::vector tree(n, std::vector<int>());
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        dfs(tree, 0, s);
        return ans + 1;
    }

    int dfs(std::vector<std::vector<int>> &tree, int i, string &s) {
        if (tree[i].empty()) {
            ans = std::max(ans, 0);
            return 0;
        }
        std::vector<int> tmp_results;
        tmp_results.reserve(tree[i].size());
        for (int child : tree[i]) {
            int child_chain = dfs(tree, child, s);
            int curr = s[i] == s[child] ? -1 : child_chain;
            tmp_results.push_back(curr);
        }
        ranges::sort(tmp_results, std::greater<>());
        // 计算经过当前节点的链的最大值
        int first = tmp_results[0];
        int second = tmp_results.size() == 1 ? -1 : tmp_results[1];
        ans = std::max(ans, first + second + 2);
        return first + 1;
    }
};
```

显然在dfs中对每一个child的结果进行排序最耗时 ($O(NlogN)$) 如何才能在遍历的过程中维护最大值和次大值呢？难道要用堆？实际也不需要。  
思考一下遍历过程，首先用一个`max_len`表示所有子节点中最长链的长度，将其初始化为0。之后遍历过程中，我们先计算当前遍历子节点的链长`curr_len`，将其与`max_len`求和，并且更新`ans`。如果先遇到了最大值，那么后续更新可以保证`ans`一定是最大+次大链；如果先遇到次大值，再遇到最大值，在遇到最大值后`ans`先被更新，然后`max_len`被更新，也可以保证结果正确，太妙了

```cpp
class Solution {
public:
    int ans = 0;
    int longestPath(vector<int>& parent, string s) {
        int n = parent.size();
        std::vector tree(n, std::vector<int>());
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        dfs(tree, 0, s);
        return ans + 1;
    }

    int dfs(std::vector<std::vector<int>> &tree, int i, string &s) {
        int max_len = 0;
        for (int child : tree[i]) {
            int len = dfs(tree, child, s) + 1;
            if (s[child] != s[i]) {
                ans = std::max(ans, max_len + len);
                max_len = std::max(max_len, len);
            }
        }
        return max_len;
    }
};
```
