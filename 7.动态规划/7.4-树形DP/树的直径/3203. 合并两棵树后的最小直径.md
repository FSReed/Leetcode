# [Description](https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/description/)

## Code

拼劲全力无法战胜，看了题解发现应该先做理论推导（见注释），得到结论后剩下的就是简单的树的直径计算，有一些值得注意的地方：

- 可以在递归过程中传入`parent`参数，这样能避免使用`visited`数组记录已访问的节点，更加简洁
- `std::function`是性能陷阱，调用的时候会查询虚表，导致性能暴跌。以后应该采用`auto dfs = [&](auto &&dfs, ...)`的形式定义原生lambda表达式

```cpp
class Solution {
public:
    int ans = 0;

    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {
        // 无向树，任意节点都可以是根节点
        // 应该尽可能让两棵树的**最长单链长度最小**的节点相连，这样贯通两棵树的新的直径会尽可能小
        // 思考一下，什么样的节点满足这种条件？**只能是直径的中点**
        // 反证一下，如果一个点不在直径上，它到达直径就需要一定距离，一定比直径上的点更劣
        // 而所有直径上的点，最优的一定是直径中点
        // PS: 注意最大直径仍然有可能存在于单棵树中
        int ans1 = diameter(edges1);
        int ans2 = diameter(edges2);
        int ans3 = (ans1 + 1) / 2 + (ans2 + 1) / 2 + 1;

        return std::max(std::max(ans1, ans2), ans3);
    }

    int diameter(vector<vector<int>>& edges) {
        int n = edges.size() + 1;   // 节点数量
        std::vector tree(n, std::vector<int>());
        for (vector<int> &pair : edges) {
            tree[pair[0]].push_back(pair[1]);
            tree[pair[1]].push_back(pair[0]);
        }

        int ans = 0;
        // std::vector<bool> visited(n, false);
        // std::function<int(int, int)> dfs = [&](int node, int parent) {
        auto dfs = [&](auto &&dfs, int node, int parent) -> int {
            // visited[node] = true;
            int max_len = 0;
            for (int &child : tree[node]) {
                // if (visited[child]) {
                //     continue;
                // }
                if (child != parent) {
                    // int len = dfs(child, node) + 1;
                    int len = dfs(dfs, child, node) + 1;
                    ans = std::max(ans, max_len + len);
                    max_len = std::max(max_len, len);
                }
            }
            return max_len;
        };
        dfs(dfs, 0, -1);
        return ans;
    }
};
```
