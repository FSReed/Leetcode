# [Description](https://leetcode.cn/problems/house-robber-iii/description/)

## Code

先写了一版超时的

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rob(TreeNode* root) {
        auto dfs = [&](auto &&dfs, TreeNode *node, bool choose_fa) -> int {
            if (node ==  nullptr) {
                return 0;
            }
            int ans = dfs(dfs, node->left, false) + dfs(dfs, node->right, false);
            if (!choose_fa) {
                // 可以选这个点
                int choose = dfs(dfs, node->left, true) + dfs(dfs, node->right, true) + node->val;
                ans = std::max(ans, choose);
            }
            return ans;
        };
        return dfs(dfs, root, false);
    }
};
```

这相当于同一个节点要遍历两次获取选或者不选，实际上一次遍历就应该足够了

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rob(TreeNode* root) {
        auto dfs = [&](auto &&dfs, TreeNode *node) -> std::pair<int, int> {
            if (node ==  nullptr) {
                return {0, 0};
            }
            auto [l_choose, l_not_choose] = dfs(dfs, node->left);
            auto [r_choose, r_not_choose] = dfs(dfs, node->right);
            auto choose = l_not_choose + r_not_choose + node->val;
            auto not_choose = std::max(l_choose, l_not_choose) + std::max(r_choose, r_not_choose);
            return {choose, not_choose};
        };
        auto [choose, not_choose] = dfs(dfs, root);
        return std::max(choose, not_choose);
    }
};
```
