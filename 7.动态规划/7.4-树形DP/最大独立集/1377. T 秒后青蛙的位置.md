# [Description](https://leetcode.cn/problems/frog-position-after-t-seconds/description/)

## Code

虽然是hard题，但是感觉并不难想，虽然处理edge case花了很多时间

```cpp
class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        // 先建树
        std::vector<std::vector<int>> tree(n + 1);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        // 对于每一个节点，其跳到target的概率是子节点跳到target概率的加权平均？
        // 子节点剩余时间只有T - 1了
        auto dfs = [&](auto &&dfs, int node, int parent, int time) -> double {
            if (time == 0) {
                return node == target ? 1.0 : 0.0;
            }

            double result = 0.0;
            int cnt = 0;
            for (int &child : tree[node]) {
                if (child == parent) {
                    continue;
                }
                double curr = dfs(dfs, child, node, time - 1);
                result += curr;
                cnt += 1;
            }
            if (node == target) {
                return cnt > 0 ? 0.0 : 1.0;
            }
            return cnt > 0 ? result / cnt : 0;
        };
        return dfs(dfs, 1, -1, t);
    }
};
```

完事之后去看看[题解](https://leetcode.cn/problems/frog-position-after-t-seconds/solutions/1/dfs-ji-yi-ci-you-qu-de-hack-by-endlessch-jtsr)，发现这个dfs中会有一些无效计算，如果一个子树中已经包含target，其他子树无需计算，一定找不到target；另外，观察到子树的返回结果都是 $(1 / len(child))$ ，那么可以每个dfs都返回子节点数目与之前dfs结果的乘积，最终在根节点处做除法，可以最大限度保留精度，速度按理说也会比浮点的快一些。

```cpp
class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        // 先建树
        std::vector<std::vector<int>> tree(n + 1);
        // 避免特判
        tree[1].push_back(0);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        // 对于每一个节点，其跳到target的概率是子节点跳到target概率的加权平均？
        // 子节点剩余时间只有T - 1了
        auto dfs = [&](auto &&dfs, int node, int parent, int time) -> long long {
            if (time == 0) {
                return node == target ? 1 : 0;
            }
            // 由于建树的时候给1分配了虚拟父节点0，此处避免了特判
            if (node == target) {
                return tree[node].size() == 1 ? 1 : 0;
            }

            for (int &child : tree[node]) {
                if (child == parent) {
                    continue;
                }
                long long curr = dfs(dfs, child, node, time - 1);
                // 已经找到了，返回当前node的子节点数目
                if (curr != 0) {
                    return curr * (tree[node].size() - 1);
                }
            }
            return 0;
        };
        long long cnt = dfs(dfs, 1, 0, t);
        return cnt != 0 ? 1.0 / cnt : 0.0;
    }
};
```
