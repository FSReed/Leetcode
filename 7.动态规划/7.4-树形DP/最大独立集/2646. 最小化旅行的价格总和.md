# [Description](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/description/)

## Code

自己从零开始思考+代码实现+AC用时44min，真的很开心，构思花费的时间大概有一半，思考过程写在注释中了，成就感非常强，而且最好的一次执行用时超过90%，性能似乎可以接受，等下看看题解有没有更好的解法

```cpp
class Solution {
public:
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        // 由于是树，所以一次旅行一定只有一条路径可选，否则路径中一定有点被重复经过，价格更高
        // 是否可以统计经过的所有节点及次数，后续dfs一个节点返回减小价格的最大值（选或者不选）
        // 最终返回原本总价格-减小价格最大值，就是最小价格总和

        // 建树
        std::vector<std::vector<int>> tree(n);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        // 先求子树以及节点次数
        std::vector<int> cnt(n, 0);
        std::vector<bool> in_set(n, false);
        auto dfs1 = [&](auto &&dfs1, int node, int target, int parent) -> bool {
            in_set[node] = true;
            if (node == target) {
                return true;
            }
            for (auto &child : tree[node]) {
                if (child == parent) {
                    continue;
                }
                if (dfs1(dfs1, child, target, node)) {
                    return true;
                }
            }
            // 没有找到，那么node不在路径上
            in_set[node] = false;
            return false;
        };
        for (auto & trip : trips) {
            std::fill(in_set.begin(), in_set.end(), false);
            dfs1(dfs1, trip[0], trip[1], -1);
            for (auto i = 0; i < n; ++i) {
                if (in_set[i]) {
                    cnt[i]++;
                }
            }
        }

        // 总价格
        int total_price = 0;
        for (auto i = 0; i < n; ++i) {
            if (cnt[i] > 0) {
                total_price += cnt[i] * price[i];
            }
        }

        // 接下来求价格的最大减少值
        std::vector<bool> visited(n, false);
        int max_reduce = 0;
        auto dfs2 = [&](auto &&dfs2, int node, int parent) -> std::pair<int, int> {
            visited[node] = true;
            int choose = cnt[node] * price[node] / 2, not_choose = 0;
            auto child_reduce_sum = 0;
            auto child_not_choose_reduce_sum = 0;
            for (auto &child : tree[node]) {
                if (child == parent || cnt[child] == 0) {
                    continue;
                }
                auto [curr_choose, curr_not_choose] = dfs2(dfs2, child, node);
                // 用于计算选node的时候不选child的减少量
                child_not_choose_reduce_sum += curr_not_choose;
                // 用于计算不选node的时候child的最大减少量
                child_reduce_sum += std::max(curr_choose, curr_not_choose);
            }
            choose += child_not_choose_reduce_sum;
            not_choose = child_reduce_sum;
            return {choose, not_choose};
        };
        for (auto i = 0; i < n; ++i) {
            if (cnt[i] > 0 && !visited[i]) {
                auto [res1, res2] = dfs2(dfs2, i, -1);
                int curr_ans = std::max(res1, res2);
                max_reduce += curr_ans;
            }
        }
        return total_price - max_reduce;
    }
};
```

看了[题解](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/solutions/2229503/lei-si-da-jia-jie-she-iii-pythonjavacgo-4k3wq)，发现我的思路和第一种解法基本是一样的，但是我在具体实现上有许多冗余的步骤，而且题解中很妙的一点是对`dfs2`方法的处理，避免了我的方法中对子集可能是森林这种情况的特殊处理，简化后代码简洁了许多：

```cpp
class Solution {
public:
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        // 优化写法
        // 优化的地方在注释中用NOTE标出

        // 建树
        std::vector<std::vector<int>> tree(n);
        for (auto &edge : edges) {
            int x = edge[0];
            int y = edge[1];
            tree[x].push_back(y);
            tree[y].push_back(x);
        }

        // 先求子树以及节点次数
        // NOTE: 不需要in_set数组，可以让递推返回bool表示target是否在其子树上
        // 自底向上“归”的时候再去更新cnt，就不需要恢复现场了
        std::vector<int> cnt(n, 0);
        auto dfs1 = [&](auto &&dfs1, int node, int target, int parent) -> bool {
            if (node == target) {
                // 找到了，更新
                cnt[node]++;
                return true;
            }
            for (auto &child : tree[node]) {
                if (child != parent && dfs1(dfs1, child, target, node)) {
                    // 找到了，当前节点是祖先，更新
                    cnt[node]++;
                    return true;
                }
            }
            return false;
        };
        for (auto & trip : trips) {
            dfs1(dfs1, trip[0], trip[1], -1);
        }

        // NOTE: 重新定义dfs，直接定义为价格的最小值(返回值为{不选，选})
        // 重点：
        // 在计算节点价格的时候直接采用price[i] * cnt[i]作为价格，然后求最小价格
        // 这样做就无需考虑路径上的节点可能组成森林的情况
        // 因为没有在路径上的点价格都为0，对于总价格不会有影响，很妙的转化
        auto dfs2 = [&](auto &&dfs2, int node, int parent) ->std::pair<int, int> {
            int not_choose = price[node] * cnt[node];   // 不选，采用更新的价格进行计算
            int choose = not_choose / 2;                // 选，价格减半
            for (const auto &child : tree[node]) {
                if (child == parent) {
                    continue;
                }
                auto [child_not_choose, child_choose] = dfs2(dfs2, child, node);
                not_choose += std::min(child_not_choose, child_choose);
                choose += child_not_choose;
            }
            return {not_choose, choose};
        };
        auto [not_choose, choose] = dfs2(dfs2, 0, -1);
        return std::min(not_choose, choose);
    }
};
```

题解里还提到一个选读方法，完全没听说过(***Tarjan 离线 LCA + 树上差分***)，至少不是我现在学习的重点，先不予理会
