# [Description](https://leetcode.cn/problems/binary-tree-cameras/description/)

## Code

自己没有想出来，一直确定不好状态如何划分，因为总会顾虑一个节点可能同时处于多种状态（比如同时被父节点和子节点监控等），实际上这完全可以，更新状态的时候从多种状态中进行更新就可以了  
另外，这道题对于递归边界的处理并没有十分显而易见，最好通过叶子节点的更新方法反推空节点返回值逻辑，我写在注释里面了

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    const int INF = 0x3f3f3f3f;
    int minCameraCover(TreeNode* root) {
        // 对于一个节点，自己可以装或者不装
        // 对于不装的状态，又有两种可能，一种是父节点装了，另一种是存在一个子节点装了
        auto dfs = [&](auto &&dfs, TreeNode *node) -> std::tuple<int, int, int> {
            if (node == nullptr) {
                // 递归边界感觉不是很好确定
                // 可以考虑将更新公式套在叶子节点上，会更好理解空节点的返回值
                // 因为返回值是为了父节点服务的，要保证父节点不会取到非法值
                return {INF, 0, 0};
            }
            auto [l_choose, l_parent, l_child] = dfs(dfs, node->left);
            auto [r_choose, r_parent, r_child] = dfs(dfs, node->right);
            // 2. 叶子节点choose的情况，只需要叶子节点上这一个摄像头就能监控当前子树
            // 换句话说，叶子节点choose返回的就是式子最后的那个1
            // 那么在确定空节点的choose返回值一定是INF之后，可以确定空节点的parent，child返回值只能是0
            int choose = std::min(l_choose, std::min(l_parent, l_child)) + std::min(r_choose, std::min(r_parent, r_child)) + 1;
            // 3. 可以验证，叶子节点被parent监控时无需安装摄像头，此时parent返回0，是正确的
            int parent = std::min(l_choose, l_child) + std::min(r_choose, r_child);
            // 1. 叶子节点不可能被空子节点监控，所以空节点安装摄像头应当返回INF
            int child = std::min(l_choose + r_choose, std::min(l_choose + r_child, l_child + r_choose));
            return {choose, parent, child};
        };
        auto [choose, parent, child] = dfs(dfs, root);
        return std::min(choose, child);
    }
};
```

这道题确定了是二叉树，如果是一般树呢？那么在`child`这一步就会存在 $2^{child\_num} - 1$ 种组合，一个个枚举写在代码中显然是不可接受的。考虑到子节点只要有一个装摄像头就可以，唯一不合法的情况就是所有子节点都不装，对应到更新逻辑中，就是所有子节点装都比不装需要更多的摄像头，如果在这种情况下让其中一个子节点装摄像头，**选装与不装价格差距最小的子节点**显然是最划算的，所以只需要每次都更新子节点最小摄像头数，在最后结果中加上所有子结点中**装与不装差值的最小值**即可，注意这个最小值需要非负，否则就不需要加这一项，因为这说明至少有一个子节点装了:

$$
child = child + max(0,\space min(curr\_choose - curr\_child))
$$

于是去[洛谷](https://www.luogu.com.cn/problem/P2458)写了灵神推荐的这道题，第一次接触ACM模式非常不适应，代码调了好久才过，注意题目里给的数据是单向边的，但是建树的时候要建双向边，否则会WA #2  
写代码的过程中可以发现，对于每一个node，一定有`by_child >= by_parent`，利用这一点可以优化`choose`的更新逻辑，详见代码：

```cpp
#include <iostream>
#include <vector>
#include <tuple>
#define INF 0x3f3f3f3f

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n;
    if (!(std::cin >> n)) return 0;
    
    std::vector<std::vector<int>> tree(n);
    std::vector<int> price(n);
    int node = 0;
    for (auto i = 0; i < n; ++i) {
        int m = 0, child = 0;
        std::cin >> node;
        std::cin >> price[node - 1];
        std::cin >> m;
        for (auto k = 0; k < m; ++k) {
            std::cin >> child;
            tree[node - 1].push_back(child - 1);
            tree[child - 1].push_back(node - 1);
        }
    }

    auto dfs = [&](auto &&dfs, int node, int fa) -> std::tuple<int, int, int> {
        int choose = price[node], by_parent = 0, by_child = 0;
        int diff = INF;
        for (auto &child : tree[node]) {
            if (child == fa) continue;
            auto [c_choose, c_parent, c_child] = dfs(dfs, child, node);
            diff = std::min(diff, c_choose - c_child);
            choose += std::min(c_choose, c_parent);     // 优化更新逻辑
            by_parent += std::min(c_choose, c_child);
            by_child += std::min(c_choose, c_child);    // 和by_parent更新逻辑一样 
        }
        by_child += std::max(0, diff);                  // 还要加一个非负数，一定不会比by_parent小
        return {choose, by_parent, by_child};
    };
    auto [choose, parent, child] = dfs(dfs, 0, -1);
    std::cout << std::min(choose, child) << std::endl;
    return 0;
}
```
