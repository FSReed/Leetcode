# [Description](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

## Code

三个月之后的复健，先写了一版递推的，没有空间优化

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 第i天的最大收益为f[i]
        // 如果第i天结束后没有持有股票，则f[i][not_hold] = max(f[i - 1][not_hold], f[i - 1][hold] + price[i])
        // 如果第i天结束后持有股票，则f[i][hold] max(f[i - 1][hold], f[i - 1][not_hold] - price[i])
        int n = prices.size();
        std::vector f(n + 1, std::vector<int>(2));
        f[0][0] = 0;
        f[0][1] = -INT_MAX;
        for (int i = 1; i <= n; ++i) {
            int new_f1 = std::max(f[i - 1][0], f[i - 1][1] + prices[i - 1]);
            int new_f2 = std::max(f[i - 1][1], f[i - 1][0] - prices[i - 1]);
            f[i][0] = new_f1;
            f[i][1] = new_f2;
        }
        return f[n][0];
    }
};
```

稍作修改

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 第i天的最大收益为f[i]
        // 如果第i天结束后没有持有股票，则f[i][not_hold] = max(f[i - 1][not_hold], f[i - 1][hold] + price[i])
        // 如果第i天结束后持有股票，则f[i][hold] max(f[i - 1][hold], f[i - 1][not_hold] - price[i])
        int n = prices.size();
        std::vector<int> f(2);
        f[0] = 0;
        f[1] = -INT_MAX;
        for (int i = 0; i < n; ++i) {
            int new_f1 = std::max(f[0], f[1] + prices[i]);
            int new_f2 = std::max(f[1], f[0] - prices[i]);
            f[0] = new_f1;
            f[1] = new_f2;
        }
        return f[0];
    }
};
```
