# [Description](https://leetcode.cn/problems/visit-array-positions-to-maximize-score/description/)

## Code

直接先干了一版 $O(N^2)$ 的，绷不住了

```cpp
class Solution {
public:
    long long maxScore(vector<int>& nums, int x) {
        // for j in range(i + 1, n):
        //   dfs(i) = max(nums[i] + dfs(j) - loss) (loss = 0 or x)
        // [2, 3, 6, 1, 9, 2]
        // dfs(i):
        // [13, 13, 11, 10, 9, 2]
        int n = nums.size();
        std::vector<int> f(n, -1);
        std::function<int(int)> dfs = [&](int i) -> int {
            if (i >= n - 1) {
                return nums[i];
            }
            if (f[i] >= 0) {
                return f[i];
            }
            int m = nums[i];
            for (int j = i + 1; j < n; ++j) {
                bool even_i = nums[i] % 2 == 0;
                bool even_j = nums[j] % 2 == 0;
                int loss = even_i == even_j ? 0 : x;
                int tmp = nums[i] + dfs(j) - loss;
                m = std::max(tmp, m);
            }
            f[i] = m;
            return m;
        };
        return dfs(0);
    }
};
```

想不出怎么构造子问题去DP，看了题解以及评论区里面的讨论，发现子问题定义并没有一个标准答案，选一个自己好理解的就可以了

### 第一种思路([灵神题解](https://leetcode.cn/problems/visit-array-positions-to-maximize-score/solutions/2810386/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-jhvr)思路)

设$dfs(i, j)$表示**下标在$[i, n - 1]$范围内的子序列中，第一个数奇偶性为$j$的子序列的最大分数**，那么对于$dfs(i, j)$，我们研究它与$dfs(i + 1, j)$以及$dfs(i + 1, 1 - j)$的关系  

如果$nums[i]$的奇偶性不为$j$，那么$dfs(i, j)$显然不选$nums[i]$

$$
dfs(i, j) = dfs(i + 1, j)
$$

如果$nums[i]$的奇偶性为$j$，那么$dfs(i, j)$**一定要选这个数**！如果不选，那么说明$dfs(i, j)$的子序列第一个数不为$nums[i]$，但是在这个子序列前面加上$nums[i]$之后结果一定比现在的$dfs(i, j)$还要大（**因为这道题里所有$nums[i]$都是正数**），矛盾。  
因此在选$nums[i]$的前提下，可以从$dfs(i + 1, j)$的两种奇偶性状态转移到$dfs(i, j)$

$$
dfs(i, j) = max(dfs(i + 1, j), dfs(i + 1, 1 - j) - x) + nums[i]
$$

代码：

```cpp
class Solution {
public:
    long long maxScore(vector<int>& nums, int x) {
        // 从后往前，因为最终nums[0]一定要选
        int n = nums.size();
        std::vector<long long> f(2, 0);
        for (int i = n - 1; i >= 0; --i) {
            int pos = nums[i] % 2;
            f[pos] = std::max(f[pos], f[1 - pos] - x) + nums[i];
        }
        return f[nums[0] % 2];
    }
};
```

### 第二种思路

直接贴一下评论区看到的代码，我琢磨了很久也没明白这个代码如何定义的子问题，状态如何转移

```cpp
class Solution(object):
    def maxScore(self, nums, x):
        """
        :type nums: List[int]
        :type x: int
        :rtype: int
        """
        @cache
        def dfs(i: int, t: int)->int:
            if i == len(nums):
                return 0
            if nums[i]%2 == t: # 相同必须选
                return dfs(i+1, t) + nums[i]
            return max(dfs(i+1, t), dfs(i+1, t ^ 1)- x + nums[i]) # 不同考虑选或不选
        
        return dfs(0, nums[0]%2)
```

还是GPT老师牛逼，一眼就给我看出来这种写法的子问题定义了：

> dfs(i, t) 表示：当前“上一个已选元素”的奇偶性是 t，并且我们正在考虑区间 [i, n)，从这里开始能获得的最大**额外分数**。

只能说人类的智慧是无穷的
