# [Description](https://leetcode.cn/problems/sorting-three-groups/description/)

这个题在线性DP里面做过，不过这次是用了不同的做法，所以再收录一次

## Code

没想到状态怎么构造，看了题解发现可以把值域作为dp的一个维度，然后发现递推公式也没那么好想，想出来后也没那么容易转化成循环，写了一版特别丑的：

```cpp
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        // 为了利用值域很小的特点，考虑把值域作为dp的一个维度
        // f(i, j)表示从0到i的子序列中 最大值不大于j的最长非递减子序列长度
        // 选i：
        //  f(i, j) = f(i - 1, j)   (nums[i] > j)
        //  f(i, j) = max(f(i - 1, j), f(i - 1, nums[i]) + 1) (nums[i] <= j)
        // 不选i：f(i, j) = f(i - 1, j)
        std::vector<int> f(4);
        f[1] = 0;
        f[2] = 0;
        f[3] = 0;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            std::vector<int> tmp_f(4);
            for (int j = 1; j <= 3; ++j) {
                if (nums[i] <= j) {
                    tmp_f[j] = std::max(f[j], f[nums[i]] + 1);
                } else {
                    tmp_f[j] = -1;
                }
            }
            f[1] = tmp_f[1] < 0 ? f[1] : tmp_f[1];
            f[2] = tmp_f[2] < 0 ? f[2] : tmp_f[2];
            f[3] = tmp_f[3] < 0 ? f[3] : tmp_f[3];
        }
        return n - f[3];
    }
};
```

再看题解，发现循环展开也挺天才的

```cpp
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        int f[4]{};
        for (int x: nums) {
            f[x]++;
            f[2] = max(f[2], f[1]);
            f[3] = max(f[3], f[2]);
        }
        return nums.size() - f[3];
    }
};
```
