# [Description](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

## Code

第一次上手写，写完注释里的公式之后直接写空间优化版本的递推，结果发现写到这地步之后完全不知道错在哪了：

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        // 设f(i, j, hold)表示第i天结束后至多卖出j次，仍然持有股票的最大收益
        // f(i, j, not_hold) = max(f(i - 1, j, not_hold), f(i - 1, j - 1, hold) + prices[i])
        // f(i, j, hold) = max(f(i - 1, j, hold), f(i - 1, j, not_hold) - prices[i])
        int n = prices.size();
        std::vector f(k + 1, std::vector<int>(2));
        f[0][1] = INT_MIN / 2;
        f[1][0] = 0;
        f[1][1] = INT_MIN / 2;
        for (int i = 0; i < n; ++i) {
            for (int j = k - 1; j >= 0; --j) {
                f[j + 1][1] = std::max(f[j + 1][1], f[j + 1][0] - prices[i]);
                f[j + 1][0] = std::max(f[j + 1][0], f[j][1] + prices[i]);
            }
        }
        return f[k][0];
    }
};
```

看了题解，发现j的取值范围有问题，数组初始化也有问题：

- `j`的取值从物理意义上来看，可以从0取到k，但是注意递推公式中j是可以取到-1的，所以一共是k + 2个值
- 数组初始化有问题。我发现这种复杂的dp公式（对我来说比较复杂），还是按照灵神说的**根据递归边界去初始化数组**最保险，比如这题如果用递归，有这样的边界：
  - 当`j < 0`时，至多交易-1次是不合法的，无论是否持有股票都不合法，返回-$\infty$。这对应初始化`f[0][0]`与`f[0][1]`为-$\infty$
  - 当`i < 0`时，持有股票不合法，未持有股票收益为0，对应`f[1][0]`到`f[k + 1][0]`初始化为0，`f[1][1]`到`f[k + 1][1]`初始化为-$\infty$。

|f|j = 0|j = 1|...|j = k + 1|
|---|---|---|---|---|
|not_hold|-$\infty$|0|0|0|
|hold|-$\infty$|-$\infty$|-$\infty$|-$\infty$|

这样就可以写出如下的代码：

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        // 设f(i, j, hold)表示第i天结束后至多卖出j次，仍然持有股票的最大收益
        // f(i, j, not_hold) = max(f(i - 1, j, not_hold), f(i - 1, j - 1, hold) + prices[i])
        // f(i, j, hold) = max(f(i - 1, j, hold), f(i - 1, j, not_hold) - prices[i])
        int n = prices.size();
        std::vector f(k + 2, std::vector<int>(2, INT_MIN / 2));
        for (int j = 1; j < k + 2; ++j) {
            f[j][0] = 0;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = k; j >= 0; --j) {
                f[j + 1][1] = std::max(f[j + 1][1], f[j + 1][0] - prices[i]);
                f[j + 1][0] = std::max(f[j + 1][0], f[j][1] + prices[i]);
            }
        }
        return f[k + 1][0];
    }
};
```

还可以思考一下如果改成**恰好k次**以及**至少k次**，解法与这个题有什么区别，其实区别在于边界条件的处理，**转移方程是一样的**([参考链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg))
