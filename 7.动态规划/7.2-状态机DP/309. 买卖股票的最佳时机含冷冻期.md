# [Description](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

## Code

冷冻期只有一天，相当于每天的交易状态多了一种（对比122题），可以写出这样的代码：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // f[i][not_hold] = max(f[i - 1][not_hold], f[i - 1][freeze])
        // f[i][hold] = max(f[i - 1][hold], f[i - 1][not_hold] - prices[i])
        // f[i][freeze] = f[i - 1][hold] + prices[i]
        int n = prices.size();
        std::vector<int> f(3);   // not_hold, hold, freeze
        f[0] = 0;
        f[1] = -INT_MAX;
        f[2] = -INT_MAX;
        for (int i = 0; i < n; ++i) {
            int not_hold = std::max(f[0], f[2]);
            int hold = std::max(f[1], f[0] - prices[i]);
            int freeze = f[1] + prices[i];
            f[0] = not_hold;
            f[1] = hold;
            f[2] = freeze;
        }
        return std::max(f[0], f[2]);
    }
};
```

看了题解评论区，发现这种做法可扩展性不好，如果冷冻期并不只有一天，那么每天就会有许多种状态，分别对应冷冻期中的不同天数。在`f[i][hold] = max(f[i - 1][hold], f[i - 2][not_hold] - prices[i])`中，注意并没有舍弃第`i - 1天not_hold，第i天买入`这种情况，因为这种情况已经包含在`f[i - 2][not_hold]`中了，同时还筛掉了`第i - 1天卖出导致not_hold`这种非法情况

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // f[i][not_hold] = max(f[i - 1][not_hold], f[i - 1][hold] + prices[i])
        // f[i][hold] = max(f[i - 1][hold], f[i - 2][not_hold] - prices[i])
        int n = prices.size();
        int pre_f = 0;   // f[i - 2][not_hold]，这个初始化需要注意
        std::vector<int> f(2);  // not_hold, hold
        f[0] = 0;
        f[1] = INT_MIN / 2;
        for (int i = 0; i < n; ++i) {
            int not_hold = std::max(f[0], f[1] + prices[i]);
            int hold = std::max(f[1], pre_f - prices[i]);
            pre_f = f[0];
            f[0] = not_hold;
            f[1] = hold;
        }
        return f[0];
    }
};
```
