# [Description](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

## Code

压着十分钟的线写出来了，卡在了`f[0] = true`这一步上，没有想懂为什么可以将`f[0]`初始化为true，其实不用太纠结意义，这个true可以保证后面`f[t - nums[i]]`在合适的时候可以被定为true。
在这之后又做了剪枝，找到结果后提前返回true，不过性能之打败了50%左右

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        auto sum = std::accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 != 0) { return false; }

        int target = sum / 2;
        // 状态转移方程：f[i + 1][t] = f[i][t] + f[i][t - nums[i + 1]]
        std::vector<bool> f(target + 1, false);
        f[0] = true;
        for (int i = 0; i < nums.size(); i++) {
            for (int t = target; t >= nums[i]; t--) {
                f[t] = f[t] || f[t - nums[i]];
                if (t == target && f[t]) {
                    return true;
                }
            }
        }
        return f[target];
    }
};
```
