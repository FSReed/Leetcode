# [Description](https://leetcode.cn/problems/target-sum/description/)

## Code

好久没写了，手生，先写一个记忆化搜索版本的

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // p - (sum - p) = target
        // p = (sum + target) / 2
        int sum = std::accumulate(nums.begin(), nums.end(), 0);
        target = target + sum;
        if (target < 0 || target % 2 != 0) { return 0; }
        target /= 2;
        int n = nums.size();
        std::vector<std::vector<int>> record(n, std::vector<int>(target + 1, -1));

        std::function<int(int, int)> dfs = [&](int i, int t) -> int {
            if (i >= n) {
                return t == 0 ? 1 : 0;
            }

            if (record[i][t] != -1) {
                return record[i][t];
            }

            if (t < nums[i]) {
                return dfs(i + 1, t);
            }
            auto result = dfs(i + 1, t) + dfs(i + 1, t - nums[i]);
            record[i][t] = result;
            return result;
        };

        return dfs(0, target);
    }
};
```

然后再改成递推：

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // p - (sum - p) = target
        // p = (sum + target) / 2
        int sum = std::accumulate(nums.begin(), nums.end(), 0);
        target = target + sum;
        if (target < 0 || target % 2 != 0) { return 0; }
        target /= 2;
        int n = nums.size();
        std::vector record(n + 1, std::vector<int>(target + 1, 0));
        record[0][0] = 1;

        for (int i = 0; i < n; i++) {
            for (int t = 0; t <= target; t++) {
                if (nums[i] > t) {
                    record[i + 1][t] = record[i][t];
                } else {
                    record[i + 1][t] = record[i][t] + record[i][t - nums[i]];
                }
            }
        }

        return record[n][target];
    }
};
```

如何只用一个数组？非常巧妙，也就是把递推式简化成$record[t] = record[t] + record[t - nums[i]]$，但是如果从左到右更新record会导致更新结果有误（可以想象一下），所以选择**从右往左**进行更新，很吊

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // p - (sum - p) = target
        // p = (sum + target) / 2
        int sum = std::accumulate(nums.begin(), nums.end(), 0);
        target = target + sum;
        if (target < 0 || target % 2 != 0) { return 0; }
        target /= 2;
        int n = nums.size();
        std::vector record(target + 1, 0);
        record[0] = 1;

        for (int i = 0; i < n; i++) {
            for (int j = target; j >= 0; j--) {
                if (j < nums[i]) { continue; }
                record[j] = record[j] + record[j - nums[i]];
            }
        }

        return record[target];
    }
};
```
