# [Description](https://leetcode.cn/problems/coin-change/description/)

## Code

又是太久不写了，写得头昏脑胀，最基础的递归版本：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 状态转移方程：s[i][target] = min(s[i][target - coins(i)] + 1, s[i + 1][target])
        int n = coins.size();
        std::vector memo(n, std::vector<int>(amount + 1, -1));

        std::function<int(int, int)> dfs = [&](int i, int target) -> int {
            if (i >= n) {
                return target == 0 ? 0 : INT_MAX / 2;
            }
            int &ans = memo[i][target];
            if (ans != -1) {
                return ans;
            }
            if (target < coins[i]) {
                ans = dfs(i + 1, target);
                return ans;
            }
            ans = std::min(dfs(i, target - coins[i]) + 1, dfs(i + 1, target));
            return ans;
        };
        auto result = dfs(0, amount);
        return result >= INT_MAX / 2 ? -1 : result;
    }
};
```

翻译成递推：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 状态转移方程：s[i][target] = min(s[i][target - coins(i)] + 1, s[i + 1][target])
        int n = coins.size();
        std::vector f(n + 1, std::vector<int>(amount + 1, INT_MAX / 2));
        f[n][0] = 0;

        for (int i = n - 1; i >= 0;  i--) {
            for (int c = 0; c <= amount; c++) {
                auto &curr = f[i][c];
                if (c < coins[i]) {
                    curr = f[i + 1][c];
                } else {
                    curr = std::min(f[i][c - coins[i]] + 1, f[i + 1][c]);
                }
            }
        }
        return f[0][amount] >= INT_MAX / 2 ? -1 : f[0][amount];
    }
};
```

只用一个数组，节省空间：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 状态转移方程：s[i][target] = min(s[i][target - coins(i)] + 1, s[i + 1][target])
        int n = coins.size();
        std::vector<int> f(amount + 1, INT_MAX / 2);
        f[0] = 0;

        for (int i = n - 1; i >= 0; i--) {
            for (int c = 0; c <= amount; c++) {
                if (c >= coins[i]) {
                    f[c] = std::min(f[c - coins[i]] + 1, f[c]);
                }
            }
        }
        return f[amount] >= INT_MAX /2 ? -1 : f[amount];
    }
};
```
