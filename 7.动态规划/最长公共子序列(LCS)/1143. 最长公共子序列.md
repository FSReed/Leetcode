# [Description](https://leetcode.cn/problems/longest-common-subsequence/description/)

## Code

先写了一版错误的，找半天没看出来错在哪：

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size(), n2 = text2.size();
        std::vector f(n1, std::vector<int>(n2, 0));
        for (int i = 0; i < n1; i++) {
            f[i][0] = text2[0] == text1[i] ? 1 : 0;
        }
        for (int j = 0; j < n2; j++) {
            f[0][j] = text1[0] == text2[j] ? 1 : 0;
        }

        for (int i = 1; i < n1; i++) {
            for (int j = 1; j < n2; j++) {
                int t1 = f[i - 1][j];
                int t2 = f[i][j - 1];
                int same = text1[i] == text2[j] ? 1 : 0;
                int t3 = f[i - 1][j - 1] + same;
                f[i][j] = std::max({t1, t2, t3});
            }
        }

        return f[n1 - 1][n2 - 1];
    }
};
```

错误在于对`f`数组的初始化，数组中`[i][j]`位置元素的含义是**前**`i, j`个子序列中的LCS长度，而非仅仅`text1[i]`与`text2[0]`这两个字符是否相同  

> 而且设置`(n1, n2)`大小的dp数组还手动初始化并非标准的dp流程，应该预留`(n1 + 1, n2 + 1)`维度的dp数组

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size(), m = text2.size();
        std::vector f(n + 1, std::vector<int>(m + 1, 0));

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int t1 = f[i - 1][j];
                int t2 = f[i][j - 1];
                int same = text1[i - 1] == text2[j - 1] ? 1 : 0;
                int t3 = f[i - 1][j - 1] + same;
                f[i][j] = std::max({t1, t2, t3});
            }
        }

        return f[n][m];
    }
};
```

但是性能巨差，因为这里面有一些中间结果的计算是不需要的，参考[这个视频](https://www.bilibili.com/video/BV1TM4y1o7ug/?vd_source=4bfc66589ec754586016938d44a64889)里面的讲解吧，优化后的逻辑可以跑到平均水平了：

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size(), m = text2.size();
        std::vector f(n + 1, std::vector<int>(m + 1, 0));

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    f[i][j] = f[i - 1][j - 1] + 1;
                } else {
                    f[i][j] = std::max(f[i - 1][j], f[i][j - 1]);
                }
            }
        }

        return f[n][m];
    }
};
```

接下来就是做空间优化，照着递推式比划一下就可以写出来，需要注意的是更新过程中可能会丢失上一轮的结果，在哪里会丢失可以画两个数组理解一下，写在注释里了：

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size(), m = text2.size();
        std::vector<int> f(m + 1, 0);

        for (int i = 1; i <= n; i++) {
            for (int j = 1, pre = f[0]; j <= m; j++) {
                int tmp = f[j];
                if (text1[i - 1] == text2[j - 1]) {
                    f[j] = pre + 1;
                } else {
                    // 注意这里可能将上一轮的f[j]更新掉，
                    // 导致下一次循环中取f[i - 1][j - 1]这一步出错，
                    // 实际取到的是f[i][j - 1]
                    f[j] = std::max(f[j], f[j - 1]);
                }
                pre = tmp;
            }
        }

        return f[m];
    }
};
```

> 至此已经很完善了，再看时间复杂度最低的一个代码发现是天书，偷一下：

```cpp
const int N=1005;
template<int S>
struct BitSet{
 #define W 6
 #define mask 63
 #define get_size(n) ((n)<1?0:((n)+mask)>>W)
 typedef unsigned long long uint;  //typedef unsigned int uint;
 uint a[get_size(S)];int size;
 void reset(){memset(a,0,sizeof(uint)*size);}
 BitSet():size(get_size(S)){reset();}
 BitSet(uint x):size(get_size(S)){reset();a[0]=x;}
 BitSet(const BitSet<S> &x):size(get_size(S)){*this=x;}
 BitSet& set(int x,int y){
  //if (y<0||y>1){printf("error!\n");return *this;}
  int X=x>>W,Y=x&mask;
  if (y)a[X]|=1ull<<Y;else a[X]&=~(1ull<<Y);
  return *this;
 }
 int find(int x)const{int X=x>>W,Y=x&mask;return (a[X]>>Y)&1ull;}
 int operator [](int x)const{return find(x);}
 BitSet& operator =(const BitSet &y){
  memcpy(a,y.a,sizeof(uint)*size);
  return *this;
 }
 BitSet<S> operator |(const BitSet<S> &y)const{return BitSet<S>(*this)|=y;}
 BitSet<S> operator &(const BitSet<S> &y)const{return BitSet<S>(*this)&=y;}
 BitSet<S> operator ^(const BitSet<S> &y)const{return BitSet<S>(*this)^=y;}
 BitSet<S> operator +(const BitSet<S> &y)const{return BitSet<S>(*this)+=y;}
 BitSet<S> operator -(const BitSet<S> &y)const{return BitSet<S>(*this)-=y;}
 BitSet<S> operator <<(int x)const{return BitSet<S>(*this)<<=x;}
 BitSet<S> operator >>(int x)const{return BitSet<S>(*this)>>=x;}
 BitSet<S> operator ~()const{return BitSet<S>(*this).flip();}
 BitSet<S>& operator =(const char *s){
  memset(a,0,sizeof(uint)*size);
  for (int i=0;i<S;++i){
   if (s[i]!='0'&&s[i]!='1')break;
   int X=i>>W,Y=i&mask;
   if (s[i]=='1')a[X]|=1ull<<Y;
  }
  return *this;
 }
 BitSet<S>& operator =(const int *s){
  memset(a,0,sizeof(uint)*size);
  for (int i=0;i<S;++i){
   if (s[i]!=0&&s[i]!=1)break;
   int X=i>>W,Y=i&mask;
   if (s[i]==1)a[X]|=1ull<<Y;
  }
  return *this;
 }
 BitSet<S>& operator <<=(int x){
  int shift=x>>W; int delta=x&mask,delta1=mask+1-delta;
  if (!x)return *this;
  if (delta==0)for (uint *p=a+size-1,*q=p-shift,*end=a+shift-1;p!=end;--p,--q)*p=*q;
  else {
   for (uint *p=a+size-1,*q1=p-shift,*q2=p-shift-1,*end=a+shift;p!=end;--p,--q1,--q2)*p=(*q1<<delta)|(*q2>>delta1);
   a[shift]=a[0]<<delta;
  }
  memset(a,0,sizeof(uint)*shift); //for (uint *p=a,*end=a+shift;p!=end;++p)*p=0;
  return *this;
 }
 BitSet<S>& operator >>=(int x){
  int shift=x>>W; int delta=x&mask,delta1=mask+1-delta;
  if (!x)return *this;
  correction();
  if (delta==0)for (uint *p=a,*q=p+shift,*end=a+size-shift;p!=end;++p,++q)*p=*q;
  else {
   for (uint *p=a,*q1=p+shift,*q2=p+shift+1,*end=a+size-shift-1;p!=end;++p,++q1,++q2)*p=(*q1>>delta)|(*q2<<delta1);
   a[size-shift-1]=a[size-1]>>delta;
  }
  memset(a+size-shift,0,sizeof(uint)*shift);
  return *this;
 }
 BitSet<S>& operator |=(const BitSet<S> &y){
  uint *startA=a;const uint *startB=y.a,*endA=a+size;
  while (startA!=endA){*startA|=*startB;++startA;++startB;}
  //for (int i=0;i<size;++i)a[i]|=y.a[i];
  return *this;
 }
 BitSet<S>& operator &=(const BitSet<S> &y){
  uint *startA=a;const uint *startB=y.a,*endA=a+size;
  while (startA!=endA){*startA&=*startB;++startA;++startB;}
  return *this;
 }
 BitSet<S>& operator ^=(const BitSet<S> &y){
  uint *startA=a;const uint *startB=y.a,*endA=a+size;
  while (startA!=endA){*startA^=*startB;++startA;++startB;}
  return *this;
 }
 BitSet<S>& operator +=(const BitSet<S> &y){
  uint t=0,*p=a,*end=a+size; const uint *q=y.a;
  while (p!=end){
   uint p1=*p; *p=p1+*q+t;
   t=(*p<p1)||(*q+t<t);
   ++p; ++q;
  }
  return *this;
 }
 BitSet<S>& operator -=(const BitSet<S> &y){
  uint t=0,*p=a,*end=a+size; const uint *q=y.a;
  while (p!=end){
   uint p1=*p; *p=p1-*q-t;
   t=(*p>p1)||(*q+t<t);
   ++p; ++q;
  }
  return *this;
 }
 operator bool()const{return count()>0;}
 BitSet<S>& flip(){
  uint *p0=a,*p1=p0+1,*p2=p0+2,*p3=p0+3,*pend=a+((size>>2)<<2);
  while (p0!=pend){
   *p0=~*p0; p0+=4;
   *p1=~*p1; p1+=4;
   *p2=~*p2; p2+=4;
   *p3=~*p3; p3+=4;
  }
  for (int i=0;i<(size&3);++i,++p0)*p0=~*p0;
  return *this;
 }

 void flip(int x){a[x>>W]^=1ull<<(x&mask);}

 int count(){
  int res=0;
  correction();
  for (int i=0;i<size;++i)res+=__builtin_popcountll(a[i]);  //popcount
  return res;
 }
 int clz(){
  correction();
  int res=0;
  if (a[size-1])res=__builtin_clzll(a[size-1])-(mask+1-(S&mask));
  else {
   res+=S&mask;
   for (int i=size-2;i>=0;--i)
    if (a[i]){res+=__builtin_clzll(a[i]); break;}
    else res+=mask+1;
  }
  return res;
 }
 int ctz(){
  correction();
  int res=0;
  for (int i=0;i<size;++i)
   if (a[i]){res+=__builtin_ctzll(a[i]); break;}
   else res+=mask+1;
  return min(res,S);
 }
 int ffs(){
  int res=ctz()+1;
  if (res==S+1)res=0;
  return res;
 }
 int _Find_first(){return ffs();}
 uint to_uint(){
  correction();
  return a[0];
 }
 void print()const{
  for (int i=0;i<size;++i)
   for (int j=0;j<=mask&&(i<<W)+j+1<=S;++j)printf("%I64d",(a[i]>>j)&1ull);
  printf("\n");
 }
 void correction(){if (S&mask)a[size-1]&=(1ull<<(S&mask))-1;}
 #undef mask
 #undef W
 #undef get_size
};
int a[N],b[N];
BitSet<N> row[2],X,Y;
unordered_map<int,vector<int> > S;
unordered_map<int,BitSet<N> > match;
class Solution {
public:
 int longestCommonSubsequence(const string &s, const string &t) {
  int n=s.size(),m=t.size();
  S.clear();match.clear();row[1].reset();
  for (int i=0;i<n;++i)S[s[i]].push_back(i);
  for (int i=0;i<m;++i)if (match.find(t[i])==match.end()){
   unordered_map<int,BitSet<N> >::iterator x=match.insert(make_pair(t[i],BitSet<N>())).first;
   for (vector<int>::iterator j=S[t[i]].begin();j!=S[t[i]].end();++j)x->second.set(*j,1);
  }
  for (int i=0,now=0;i<m;++i,now^=1)
   X=(row[now^1]|match[t[i]]).set(n,1),row[now]=(X&((X-(row[now^1]<<1).set(0,1))^X)).set(n,0);
  return row[(m-1)&1].count();
 }
};
```
