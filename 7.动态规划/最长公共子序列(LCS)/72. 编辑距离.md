# [Description](https://leetcode.cn/problems/edit-distance/description/)

## Code

原本是hard，不知道为啥现在成了mid，他妈的，写不了一点  
写状态转移方程就没写出来，按照刚写完1143题的劲头直接翻译成一维数组，发现根本不知道怎么初始化：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        std::vector<int> f(m + 1, 0);

        for (int i = 0; i < n; i++) {
            int prev = f[0];
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1];
                // 翻译状态转移方程；
                if (word1[i] == word2[j]) {
                    f[j + 1] = prev;
                } else {
                    f[j + 1] = std::min({f[j + 1], f[j], prev}) + 1;
                }
                prev = tmp;
            }
        }
        return f[m];
    }
};
```

再去看题解，原来当一个字符串的长度到达0的时候，就说明至少需要`另一个字符串长度`的次数才能让两个字符串相同(也就是把另一个字符串都删光)，于是就有了这题特殊的初始化：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        std::vector<int> f(m + 1);
        // 初始化i = 0时的f[j]值
        for (int j = 0; j <= m; j++) {
            f[j] = j;
        }

        for (int i = 0; i < n; i++) {
            int prev = f[0];
            // 初始化f(i + 1, 0)
            f[0] = i + 1;
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1];
                // 翻译状态转移方程；
                if (word1[i] == word2[j]) {
                    f[j + 1] = prev;
                } else {
                    f[j + 1] = std::min({f[j + 1], f[j], prev}) + 1;
                }
                prev = tmp;
            }
        }
        return f[m];
    }
};
```

说真的，跑通了还是觉得有点模模糊糊的
