# [Description](https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/)

很难，收获很多

## Code

不愧是hard，2423分，实在是难想，简单看了下[题解](https://leetcode.cn/problems/minimum-cost-to-merge-stones/solutions/2207235/tu-jie-qu-jian-dpzhuang-tai-she-ji-yu-yo-ppv0)里面的寻找子问题思路，自己慢慢摸索着写了一版记忆化搜索，过程以及中间的踩坑都放在注释里了：

```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        // 不看题解我是真想不到怎么分解原问题找子问题
        // 假如最后只剩下k堆石头，考虑第一块石头是怎么来的
        // 可能就是原本的第一堆石头，或者合并了一次，两次...
        // 如果合并了m次，那么说明一共减少了(k - 1) * m个石堆
        // 记j = (k - 1) * m
        // 剩下k - 1堆合并的最小成本是dfs(j + 1, n - 1, k - 1)
        // 第一堆的最小成本是dfs(0, j, 1)
        // 递推式：dfs(0, n - 1, k) = min(dfs(0, j, 1) + dfs(j + 1, n - 1, k - 1)), m变化
        // 尝试一般化:
        // dfs(i, j, p) = min(dfs(i, i + (k - 1) * m, 1) + dfs(i + (k - 1) * m + 1, j, p - 1))
        // 递归入口dfs(0, n - 1, k)，最后加上全数组成本之和
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }
        int f[n][n][k];
        memset(f, -1, sizeof(f));

        std::function<int(int, int, int)> dfs = [&](int i, int j, int p) {
            int &result = f[i][j][p];
            if (result >= 0) {
                return result;
            }
            if (p == 1) {
                // 原本的错误边界：
                // if ((j - i) % (k - 1) != 0) {
                //     return -1;
                // }
                // 这完全是不可能的，进入第一次dfs前已经把无法合并成一堆的题目提前return -1了
                // 而且后面的循环也都是按照k - 1的个数往上加石头，一定存在合法的合并情况
                // 正确的边界是如果p = 1且只有一块石头，说明无需合并，没有成本，return 0
                if (i == j) {
                    return 0;
                }
                return dfs(i, j, k) + std::accumulate(stones.begin() + i, stones.begin() + j + 1, 0);
            }
            result = INT_MAX;
            for (int m = 0; (k - 1) * m + i <= j - (p - 1); ++m) {
                int first = dfs(i, i + (k - 1) * m, 1);
                int rest = dfs((k - 1) * m + i + 1, j, p - 1);
                result = std::min(result, first + rest);
            }
            // 多余判断，此dfs条件下所有dfs状态一定都合法
            // 因为划分出的子问题都是合法的
            // return result == INT_MAX ? -1 : result;
            return result;
        };
        return dfs(0, n - 1, 1);
    }
};
```

我个人感觉最困难的是自己寻找dfs边界的过程，因为我忽略了dfs里面的for循环每次划分出来的子问题都一定是合法的，所以无需一次次判断当前子问题是否有解（比如`p == 1`里面被注释掉的判断逻辑）。
后面发现还有一些可以优化的点，比如：

- for循环写得实在太丑了，为了使用刻板印象`++m`强行把m定义为合并次数，丑得离谱
- 数组求和可以用前缀和数组加速计算

```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }

        // 前缀和数组
        int pre[n + 1];
        pre[0] = 0;
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + stones[i];
        }

        int f[n][n][k];
        memset(f, -1, sizeof(f));
        std::function<int(int, int, int)> dfs = [&](int i, int j, int p) {
            int &result = f[i][j][p];
            if (result >= 0) {
                return result;
            }
            if (p == 1) {
                if (i == j) {
                    return 0;
                }
                return dfs(i, j, k) + pre[j + 1] - pre[i];
            }
            result = INT_MAX;
            for (int m = i; m < j; m += k - 1) {
                result = std::min(result, dfs(i, m, 1) + dfs(m + 1, j, p - 1));
            }
            return result;
        };
        return dfs(0, n - 1, 1);
    }
};
```

然而翻译成递推的过程并不顺利。起初一切都很顺利，正确初始化递归边界，确定i倒序遍历，j正序遍历，p倒序遍历（见代码注释），然而跑出来的结果总是不对，或者有时会有加法越界，让我很头疼

- 第一次跑通递推是在最内层循环里加上了判断`f[i][j][p]`是否有解的if判断语句，如果肯定无解就提前返回0，虽然跑通了，但是这显然并不是1：1翻译记忆化搜索。记忆化搜索天然就可以免于计算无解的状态，而递推要确保每个状态都被计算
- 问了AI，发现原来是**数组初始化的问题**：原始数组应该初始化为INF，表示成本无穷大，这样后面才可以取最小值找到答案，然而我原本直接用了初始值0，这就导致肯定无解的状态被初始化为成本0，纯胡闹

递推代码：

```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }

        // 前缀和数组
        int pre[n + 1];
        pre[0] = 0;
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + stones[i];
        }

        int f[n][n][k + 1];
        memset(f, 0x3f, sizeof(f)); // 这样初始化后每个int都是0x3f3f3f3f，是一个常用INF数
        // i倒序遍历，j正序遍历，p正序遍历
        // 边界是p == 1且i == j时返回0
        for (int i = n - 1; i >= 0; i -= 1) {
            for (int j = i; j < n; j += 1) {
                for (int p = k; p >= 1; --p) {
                    if (p == 1) {
                        f[i][j][1] = i == j ? 0 : f[i][j][k] + pre[j + 1] - pre[i];
                    } else {
                        int &result = f[i][j][p];
                        result = INT_MAX / 2;   // 避免p == 1计算求和时候溢出
                        for (int m = i; m < j; m += k - 1) {
                            result = std::min(result, f[i][m][1] + f[m + 1][j][p - 1]);
                        }
                    }
                }
            }
        }
        return f[0][n - 1][1];
    }
};
```

更nb的思路：**第三个维度是多余的**。在三维dp挣扎的过程中，其实可以发现有许多状态是永远不会被计算的，这就驱使我们思考是否可以优化一些状态。多余的状态指的是：对于定长区间[i, j]，最终**能够**合并成的石头堆数已经确定了，**定义`dfs(i, j)`表示`[i, j]`区间上的石堆合并后得到最少堆数的最小成本**，同时将石堆划分为两堆，一左一右

$$
dfs(i, j) = min(dfs(i, m), dfs(m + 1, j)), m = i + x(k - 1), x = 0, 1, 2...
$$

这样可以保证`dfs(i, m)`一定可以合并为一堆，而`dfs(m + 1, j)`则不一定。根据这个公式求出`dfs(i, j)`之后，我们**需要判断`[i, j]`区间是否可以合并为一堆，如果可以的话，更新`dfs(i, j)`**:

$$
dfs(i, j) = dfs(i, j) + \sum_{k = i}^j stones[k], (j - i) \% (k - 1) = 0
$$

经历上面这么多折磨后，这个二维的dp思路其实不难看懂，但是要想自己想出来，需要对这个题目中的数学规律有很深刻的认识才可以，真的难啊。  
直接写递推版本还出现了一个小问题，内层的递推初值设置出现了问题。可以先想一想，在当前二维dp的状态转移定义下，`j`的初值应该设置为多少？（详见注释）

```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }

        // 前缀和数组
        int pre[n + 1];
        pre[0] = 0;
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + stones[i];
        }

        int f[n][n];
        memset(f, 0x3f, sizeof(f));
        for (int i = n - 1; i >= 0; --i) {
            f[i][i] = 0;
            // 下面的循环初值一开始写成j = i了，报错
            // 原因是状态转移理解不到位
            // 状态转移方程已经认为区间[i, j]会被分成左右两堆了，不会再考虑一个石堆的情况
            for (int j = i + 1; j < n; ++j) {
                int &result = f[i][j];
                for (int m = i; m < j; m += (k - 1)) {
                    result = std::min(result, f[i][m] + f[m + 1][j]);
                }
                if ((j - i) % (k - 1) == 0) {
                    result += pre[j + 1] - pre[i];
                }
            }
        }
        return f[0][n - 1];
    }
};
```
