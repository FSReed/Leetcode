# [Description](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/)

## Code

好精妙的题目，第一次见到不知道如何翻译成递推的dp，看了[视频](https://www.bilibili.com/video/BV1Gs4y1E7EU/)后自己先写了一版递归的，感觉状态转移过程乱七八糟，k到处乱跳，真能递推吗

```cpp
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        // 连线(i, j)点，可以将多边形分成两个小的多边形
        // 额外如果在顺时针顺序中间找一个k点，就可以拼成一个三角形
        // dfs(i, j) = min(v[i] * v[j] * v[k] + dfs(i, k) + dfs(k, j)), i < k < j
        // 递归入口是dfs(0, n - 1)
        int n = values.size();
        std::vector f(n, std::vector<int>(n, INT_MAX));
        std::function<int(int, int)> dfs = [&](int i, int j) -> int {
            if (j < i + 2) {
                return 0;
            }
            if (f[i][j] != INT_MAX) {
                return f[i][j];
            }
            int &result = f[i][j];
            for (int k = i + 1; k < j; ++k) {
                int curr = values[i] * values[j] * values[k];
                result = std::min(result, curr + dfs(i, k) + dfs(k, j));
            }
            return result;
        };
        return dfs(0, n - 1);
    }
};
```

翻译成递推也是可以的

```cpp
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        // 连线(i, j)点，可以将多边形分成两个小的多边形
        // 额外如果在顺时针顺序中间找一个k点，就可以拼成一个三角形
        // dfs(i, j) = min(v[i] * v[j] * v[k] + dfs(i, k) + dfs(k, j)), i < k < j
        // 递归入口是dfs(0, n - 1)
        
        // 观察原始式子，可以发现dfs(i, j)中的i都由更大的i转化而来，j都由更小的j转化而来
        // 所以采用i倒序枚举，j正序枚举翻译出来的递推仍然是正确的
        // 边界条件是i + 1 <= j返回0，所以j最大是n - 1，i最大就是n - 3
        // 而且注意i + 1 == j的情况下要返回0，据此做一些初始化
        int n = values.size();
        std::vector f(n, std::vector<int>(n, INT_MAX));
        for (int i = 0; i < n - 1; ++i) {
            f[i][i + 1] = 0;
        }
        for (int i = n - 3; i >= 0; --i) {
            for (int j = i + 2; j < n; ++j) {
                for (int k = i + 1; k < j; ++k) {
                    int curr = values[i] * values[j] * values[k];
                    f[i][j] = std::min(f[i][j], curr + f[i][k] + f[k][j]);
                }
            }
        }
        return f[0][n - 1];
    }
};
```
