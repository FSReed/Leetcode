# [Description](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

## Code

子问题定义很清晰，dfs好写：

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dfs(i, j)表示区间[i, j]上的最长回文子序列
        // 如果s[i], s[j]相同，一定有dfs(i, j) = dfs(i + 1, j - 1) + 2
        // 如果不同，找最大值:
        // dfs(i, j) = max(dfs(i + 1, j), dfs(i, j - 1))
        int n = s.size();
        std::vector f(n + 1, std::vector<int>(n + 1, -1));
        std::function<int(int, int)> dfs = [&](int i, int j) -> int {
            if (i > j) {
                return 0;
            }
            if (i == j) {
                return 1;
            }
            
            if (f[i][j] >= 0) {
                return f[i][j];
            }

            int &result = f[i][j];

            if (s[i] == s[j]) {
                result = dfs(i + 1, j - 1) + 2;
            } else {
                result = std::max(dfs(i + 1, j), dfs(i, j - 1));
            }
            return result;
        };
        return dfs(0, n - 1);
    }
};
```

那么要怎么把dfs公式翻译成递推呢？公式已经写好，关键还是找递归边界：**当 $i >= j$ 的时候递归结束**，其中 $i > j$ 的时候返回0，$i == j$ 的时候返回1，所以 **$j$ 应该从 $i + 1$ 开始递推**

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dfs(i, j)表示区间[i, j]上的最长回文子序列
        // 如果s[i], s[j]相同，一定有dfs(i, j) = dfs(i + 1, j - 1) + 2
        // 如果不同，找最大值:
        // dfs(i, j) = max(dfs(i + 1, j), dfs(i, j - 1))

        // 递归边界为 i >= j
        // 翻译成递推的时候要观察一下状态转移方式
        // 对于i，从i + 1转移到i，所以i要从后往前遍历
        // 对于j，从j - 1转移到j，所以j要从前往后遍历
        int n = s.size();
        std::vector f(n, std::vector<int>(n, 0));
        for (int i = n - 1; i >= 0; --i) {
            f[i][i] = 1;    // i == j返回1
            for (int j = i + 1; j < n; ++j) {
                if (s[i] == s[j]) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = std::max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
};
```

翻译成一维数组空间优化也费了点时间，还是对多余的状态和状态转移过程不熟悉

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dfs(i, j)表示区间[i, j]上的最长回文子序列
        // 如果s[i], s[j]相同，一定有dfs(i, j) = dfs(i + 1, j - 1) + 2
        // 如果不同，找最大值:
        // dfs(i, j) = max(dfs(i + 1, j), dfs(i, j - 1))
        // 递归边界为 i >= j
        // 翻译成递推的时候要观察一下状态转移方式
        // 对于i，从i转移到i+1，所以i要从后往前遍历
        // 对于j，从j转移到j-1，所以j要从前往后遍历
        int n = s.size();
        std::vector f(n, 0);
        for (int i = n - 1; i >= 0; --i) {
            f[i] = 1;
            int pre = 0;    // 下面的循环中，pre初始值应为f[i + 1][i]，也就是0
            for (int j = i + 1; j < n; ++j) {
                int tmp = f[j]; // 保存上一轮f[i + 1][j]的值
                // 更新f[i][j]
                if (s[i] == s[j]) {
                    f[j] = pre + 2;
                } else {
                    f[j] = std::max(f[j], f[j - 1]);
                }
                pre = tmp;
            }
        }
        return f[n - 1];
    }
};
```
