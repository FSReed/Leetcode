# [Description](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/description/)

## Code

看到是hard吓了一跳，分析了一下感觉和三角剖分的形式有点像，首先利用`cuts`数组构建一个棍子，分区间求最小成本就行了，还是先写了一版dfs的，结果有一些用例超出内存限制，通过样例数 $74/101$

```cpp
class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        // 假设在[i, j]区间上的k位置切了一刀，那么[i, j]区间的成本为
        // dfs(i, j) = j - i(切的这一刀) + dfs(i, k) + dfs(k, j)
        std::vector<bool> bar(n + 1, false);
        for (int cut: cuts) {
            bar[cut] = true;
        }

        std::vector f(n + 1, std::vector<int>(n + 1, INT_MAX));
        std::function<int(int, int)> dfs = [&](int i, int j) {
            if (i + 1 >= j) {
                return 0;
            }
            if (f[i][j] != INT_MAX) {
                return f[i][j];
            }
            int &result = f[i][j];
            bool is_cut = false;
            for (int k = i + 1; k < j; ++k) {
                if (bar[k]) {
                    is_cut = true;
                    result = std::min(result, j - i + dfs(i, k) + dfs(k, j));
                }
            }
            result = is_cut ? result : 0;
            return result;
        };
        return dfs(0, n);
    }
};
```

OOM这个样例单独去跑，结果是正确的，而且通过样例数目足够多，看来dp的思路是正确的，接下来看看哪里可以做空间优化  
首先想到的就是转化成递推，我不认为空间复杂度还可以再优化，那就试试优化下递归的调用栈，转化成递推。递归边界是 $i + 1 >= j$ 时返回0，那么递推边界的j应该从i + 2开始，而j最大值是n，所以i最大值应该是n - 2。注意状态转移过程，i应该倒序遍历，j正序遍历

```cpp
class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        // 假设在[i, j]区间上的k位置切了一刀，那么[i, j]区间的成本为
        // dfs(i, j) = j - i(切的这一刀) + dfs(i, k) + dfs(k, j)
        std::vector<bool> bar(n + 1, false);
        for (int cut: cuts) {
            bar[cut] = true;
        }

        std::vector f(n + 1, std::vector<int>(n + 1, INT_MAX));
        for (int i = 0; i < n; ++i) {
            f[i][i + 1] = 0;
        }
        for (int i = n - 2; i >= 0; --i) {
            for (int j = i + 2; j <= n; ++j) {
                bool is_cut = false;
                for (int k = i + 1; k < j; ++k) {
                    if (bar[k]) {
                        is_cut = true;
                        f[i][j] = std::min(f[i][j], j - i + f[i][k] + f[k][j]);
                    }
                }
                f[i][j] = is_cut ? f[i][j] : 0;
            }
        }
        return f[0][n];
    }
};
```

结果现在有算例超时了，心态大崩  
看了题解后，发现我这里是在整根棍子上遍历，时间复杂度是 $O(N ^ 3)$ ,空间复杂度是 $O(N ^ 2)$ ，而实际上只需要在`cuts`数组上遍历即可，复杂度里面的 $N$ 都可以替换成`cuts`数组长度 $m$  
这也是我第一次比较直观地体会到数据范围对算法题的影响，题目已经给出 `2 <= n <= 10^6`，而`1 <= cuts.length <= min(n - 1, 100)`，显然在整根棍子上去操作是不可能的，以后应该注意

```cpp
// 递归
class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        // 假设在[i, j]区间上的k位置切了一刀，那么[i, j]区间的成本为
        // dfs(i, j) = j - i(切的这一刀) + dfs(i, k) + dfs(k, j)
        cuts.push_back(0);
        cuts.push_back(n);
        ranges::sort(cuts);

        int m = cuts.size();
        std::vector f(m + 1, std::vector<int>(m + 1, INT_MAX));
        std::function<int(int, int)> dfs = [&](int i, int j) {
            if (i + 1 >= j) {
                return 0;
            }
            if (f[i][j] != INT_MAX) {
                return f[i][j];
            }
            int &result = f[i][j];
            for (int k = i + 1; k < j; ++k) {
                result = std::min(result, cuts[j] - cuts[i] + dfs(i, k) + dfs(k, j));
            }
            return result;
        };
        return dfs(0, m - 1);
    }
};
```

```cpp
// 递推
class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        // 假设在[i, j]区间上的k位置切了一刀，那么[i, j]区间的成本为
        // dfs(i, j) = j - i(切的这一刀) + dfs(i, k) + dfs(k, j)
        cuts.push_back(0);
        cuts.push_back(n);
        ranges::sort(cuts);

        int m = cuts.size();
        std::vector f(m + 1, std::vector<int>(m + 1, INT_MAX));
        for (int i = 0; i < m; ++i) {
            f[i][i + 1] = 0;
        }
        for (int i = m - 2; i >= 0; --i) {
            for (int j = i + 1; j < m; ++j) {
                for (int k = i + 1; k < j; ++k) {
                    f[i][j] = std::min(f[i][j], cuts[j] - cuts[i] + f[i][k] + f[k][j]);
                }
            }
        }
        return f[0][m - 1];
    }
};
```
