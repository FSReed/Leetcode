# [Description](https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/description/)

和[516](<./516. 最长回文子序列.md>)有很大关联，但是获取答案的手段很高明

## Code

先试着自己写了一版，基本都按照最长回文串那道题去写，区别在于如果从两个字符串都取过字符，后续就不再限制必须再从两个字符串都取子串，否则本次dfs不合法，结果在一个算例上报错了 ( $95/109$ )

```cpp
class Solution {
public:
    int longestPalindrome(string word1, string word2) {
        // 似乎可以将两个字符串拼一起，如果dfs(i, j)只位于一个字符串区间内，则不合法，返回0
        // 其他的按照最长回文串做
        int cut_pos = word1.size();
        std::string word = word1 + word2;
        int n = word.size();
        std::vector f(n, std::vector<int>(n, -1));
        std::function<int(int, int, bool)> dfs = [&](int i, int j, bool legal) {
            if ((i >= cut_pos || j < cut_pos) && !legal) {
                // 正在搜索某一个字符串，不合法
                return 0;
            }
            
            if (f[i][j] >= 0) {
                return f[i][j];
            }
            if (i > j) {
                return 0;
            }
            if (i == j) {
                return 1;
            }
            int &result = f[i][j];
            if (word[i] == word[j]) {
                // ERROR: 如果已经满足legal，子问题会退化成最简单的最长回文串，使用记忆结果是错误的
                result = dfs(i + 1, j - 1, true) + 2;
            } else {
                result = std::max(dfs(i, j - 1, legal), dfs(i + 1, j, legal));
            }
            return result;
        };
        return dfs(0, n - 1, false);
    }
};
```

报错的算例：

```text
word1 = "knzgidixqgtnaha"
word2 = "mebx"
正确答案应为5，程序输出2
```

debug过程中，发现应该是记忆化搜索的记忆数组出现了问题，按理说`f[7][14]`(也就是`word1`的子串`xqgtnaha`)应该记录着最长回文串长度5，但实际是-1，根本没有遍历到；再看答案所在区间`[7, 18]`，当执行`dfs(7, 18)`时，发现左右两端字符相等，于是进入`dfs(8, 17)`，但是`dfs(8, 17)`已经被遍历过并且被记录为0，这是因为`[8, 17]`区间上对于本题而言没有答案，然而我们这次进入`dfs(8, 17)`**已经处于合法状态**，单纯是为了找最长回文串，导致错误  
找到问题所在后，琢磨了一下，感觉这种加一个状态计算`dfs(i, j, legal)`的写法应该还需要另一个朴素的`dfs(i, j)`去单独计算回文串长度，不是理想的做法，遂看了[题解](https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/solutions/2285215/shi-pin-qiao-miao-zhuan-huan-516-bian-xi-jhrt)，发现一种新的思路：**在dfs过程中某些时刻更新答案**。比如这个题目，使用最简单的最长回文串dfs，只在`s[i] == s[j]`的时候判断是否从两个字符串中都取了字符，如果是，那么更新一下答案，如果不是，不更新答案继续计算即可，太妙了！

```cpp
class Solution {
public:
    int longestPalindrome(string word1, string word2) {
        int cut_pos = word1.size();
        std::string word = word1 + word2;
        int n = word.size();

        std::vector f(n, std::vector<int>(n, -1));
        int ans = 0;
        std::function<int(int, int)> dfs = [&](int i, int j) {
            if (f[i][j] >= 0) {
                return f[i][j];
            }
            if (i > j) {
                return 0;
            }
            if (i == j) {
                return 1;
            }
            int &result = f[i][j];
            if (word[i] == word[j]) {
                result = dfs(i + 1, j - 1) + 2;
                // 判断下是否要更新
                if (i < cut_pos && j >= cut_pos) {
                    ans = std::max(ans, result);
                }
            } else {
                result = std::max(dfs(i, j - 1), dfs(i + 1, j));
            }
            return result;
        };
        dfs(0, n - 1);
        return ans;
    }
};
```

翻译成递推，并且用类似[516](<./516. 最长回文子序列.md>)的方式空间优化：

```cpp
class Solution {
public:
    int longestPalindrome(string word1, string word2) {
        int cut_pos = word1.size();
        std::string word = word1 + word2;
        int n = word.size();

        std::vector<int> f(n, 0);
        int ans = 0;
        for (int i = n - 2; i >= 0; --i) {
            f[i] = 1;
            int pre = 0;
            for (int j = i + 1; j < n; ++j) {
                int tmp = f[j];
                if (word[i] == word[j]) {
                    f[j] = pre + 2;
                    if (i < cut_pos && j >= cut_pos) {
                        ans = std::max(ans, f[j]);
                    }
                } else {
                    f[j] = std::max(f[j - 1], f[j]);
                }
                pre = tmp;
            }
        }
        return ans;
    }
};
```
