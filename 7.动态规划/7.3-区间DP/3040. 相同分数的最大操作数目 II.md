# [Description](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/description/)

## Code

我首先想到的思路是三个递归入口，从原数组三种操作开始，记录各个入口的分数，之后这个分数就不会变了，相当于三组区间dp，每组计算前重置记忆化数组，感觉相当丑，但是能过  
需要注意的点是dfs里面return的结果，由于result有可能是-1，代表当前区间 $[i, j]$ 没有符合分数要求的删除方法，这时候应该返回0而非-1，否则后续dfs结果也会出问题

```cpp
class Solution {
public:
    int maxOperations(vector<int>& nums) {
        int n = nums.size();
        std::vector f(n, std::vector<int>(n, -1));
        std::function<int(int, int, int)> dfs = [&](int i, int j, int p) -> int {
            if (i >= j) {
                return 0;
            }
            if (f[i][j] >= 0) {
                return f[i][j];
            }
            int &result = f[i][j];
            if (nums[i] + nums[j] == p) {
                result = std::max(result, dfs(i + 1, j - 1, p) + 1);
            }
            if (nums[i] + nums[i + 1] == p) {
                result = std::max(result, dfs(i + 2, j, p) + 1);
            }
            if (nums[j - 1] + nums[j] == p) {
                result = std::max(result, dfs(i, j - 2, p) + 1);
            }
            return result > 0 ? result : 0; // 注意返回结果的处理
        };
        
        int res1 = dfs(2, n - 1, nums[0] + nums[1]);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                f[i][j] = -1;
            }
        }
        int res2 = dfs(0, n - 3, nums[n - 2] + nums[n - 1]);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                f[i][j] = -1;
            }
        }
        int res3 = dfs(1, n - 2, nums[0] + nums[n - 1]);
        
        return std::max(res1, std::max(res2, res3)) + 1;
    }
};
```

先不看题解有没有更nb的做法，先翻译成递推优化下空间看看效率如何

```cpp
class Solution {
public:
    int maxOperations(vector<int>& nums) {
        // dfs(i, j, p) = dfs(i + 1, j - 1, p) + 1 or dfs(i, j - 2, p) or dfs(i + 2, j, p)
        int n = nums.size();
        
        int res1 = dfs(nums, nums[0] + nums[1]);
        
        int res2 = dfs(nums, nums[n - 2] + nums[n - 1]);
        
        int res3 = dfs(nums, nums[0] + nums[n - 1]);
        
        return std::max(res1, std::max(res2, res3));
    }

private:
    int dfs(std::vector<int> &nums, int target) {
        int n = nums.size();
        std::vector f(n + 1, std::vector<int>(n + 1, 0));
        for (int i = n - 2; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[i + 1] == target) {
                    f[i][j + 1] = std::max(f[i][j + 1], f[i + 2][j + 1] + 1);
                }
                if (nums[j - 1] + nums[j] == target) {
                    f[i][j + 1] = std::max(f[i][j + 1], f[i][j - 1] + 1);
                }
                if (nums[i] + nums[j] == target) {
                    f[i][j + 1] = std::max(f[i][j + 1], f[i + 1][j] + 1);
                }
            }
        }
        return f[0][n];
    }
};
```

翻译过程很成功，但是却发现效率反倒比递归还要差了，这让我有些吃惊。于是去看了[题解](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/solutions/2643756/qu-jian-dp-de-tao-lu-pythonjavacgo-by-en-nynz)，发现思路没什么问题，但是递归的时候如果三个`if`都不满足，本次递归就结束了，但是递推不行，还是要继续计算其他状态，所以**本题递推效率不如记忆化搜索**  
另外递归还可以做剪枝，因为分析一下这个题目，答案的最大可能值是`floor(n / 2)`，如果已经找到了这个答案，后面的计算都可以不做了，如果是在第一组dp中就找到了最大答案，剩下两组dp甚至都可以不做。这样的剪枝在第一版dfs基础上加一个`done`，当递归到 $i >= j$ 的时候就可以表示答案为最大值了，因为递归深度变大只可能发生在dfs中的三个if语句里，能递归到 $i >= j$ 已经说明前面把所有能删除的全删掉了  
题解里还有一点比较诡异的：计算第二次和第三次区间DP的时候**没有必要重新初始化`f`数组**，我试了一下确实还能通过，摘录一下题解的原话吧，这一点我确实想不到：

> 代码实现时，在计算第二次区间 DP 和第三次区间 DP 时，无需重置 memo 数组，这是因为不同的 target 不会递归到同一对 (i,j) 上。这可以用反证法证明：假如不同的 target 递归到同一对 (i,j) 上，这说明之前的操作次数相同，且删除的元素和相同，所以两次区间 DP 对应的得分是相同的，矛盾。

```cpp
class Solution {
public:
    int maxOperations(vector<int>& nums) {
        int n = nums.size();
        std::vector f(n, std::vector<int>(n, -1));
        bool done = false;
        std::function<int(int, int, int)> dfs = [&](int i, int j, int p) -> int {
            if (i >= j) {
                done = true;
                return 0;
            }
            if (done) {
                return 0;
            }
            if (f[i][j] >= 0) {
                return f[i][j];
            }
            int &result = f[i][j];
            if (nums[i] + nums[j] == p) {
                result = std::max(result, dfs(i + 1, j - 1, p) + 1);
            }
            if (nums[i] + nums[i + 1] == p) {
                result = std::max(result, dfs(i + 2, j, p) + 1);
            }
            if (nums[j - 1] + nums[j] == p) {
                result = std::max(result, dfs(i, j - 2, p) + 1);
            }
            return result > 0 ? result : 0;
        };
        
        int res1 = dfs(2, n - 1, nums[0] + nums[1]);
        // for (int i = 0; i < n; ++i) {
        //     for (int j = 0; j < n; ++j) {
        //         f[i][j] = -1;
        //     }
        // }
        int res2 = dfs(0, n - 3, nums[n - 2] + nums[n - 1]);
        // for (int i = 0; i < n; ++i) {
        //     for (int j = 0; j < n; ++j) {
        //         f[i][j] = -1;
        //     }
        // }
        int res3 = dfs(1, n - 2, nums[0] + nums[n - 1]);
        
        return std::max(res1, std::max(res2, res3)) + 1;
    }
};
```
