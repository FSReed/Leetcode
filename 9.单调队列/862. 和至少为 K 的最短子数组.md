# [Description](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/)

## Code

完全没思路，不知道怎么转换为单调队列问题，看了[题解](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)才知道可以利用前缀和  

- 用前缀和构造单调队列的关键思想是：如果在区间`[i, j]`上的子数组之和已经满足条件，那么后面得到的子数组如果想要成为答案，无论如何不可能以`i`为左端点了。每次找到符合要求的子数组都去更新一下答案

仅有上面一点还不够，可能有一个巨大的数字出现导致答案更新的极端情况，仅这一个数就已经大于等于k了，比如这个样例:

```text
[84,-37,32,40,95]
k = 167
```

在下标到达4的时候才找到第一个满足要求的子数组，但是我们把84和-37都剔除之后，会发现`[32, 40, 95]`才是满足要求的最短子数组，该如何考虑这种情况？  
想了半天还是没想出来，结果看了题解发现有一步（在我看来）非常不符合单调队列模板的做法：如果遍历到前缀和`pre[i]`的时候，某个`i`之前的下标`j`满足`pre[j] <= pre[i]`，那么这个`j`会**被从队尾弹出**。我靠，怎么单调队列还能从队尾弹的？  
弹出的理由相对直观，因为如果`i`后面某个下标`t`满足`pre[t] - pre[j] >= k`，那么也一定同时满足`pre[t] - pre[i] >= k`，而且区间`[i, t]`的子数组一定比区间`[j, t]`更短。但是这样弹不会丢失答案吗？这是怎么想到要这样弹还能保证正确性的？  
对于这个思路上不自然的点，我去问了一下AI，AI提到的一点我认为很有价值：**要注意单调队列是在维护什么值**。的确，我一直没有想明白这个单调队列在维护什么，实际上，它维护的是所有可能成为答案的子数组**左端点**下标值。如果认清这个事实，那么从队尾弹出元素就非常直观了，从队尾弹出的值一定不会成为未来的左端点，并且这样做不会丢失答案。

- 沿用上面的记号，假如从队尾弹出了`j`，是否可能存在一个下标`t`且`t < j`，使得`[t, i]`组成答案而丢失了`[t, j]`？绝不可能，因为在此之前`[t, j]`一定满足要求，并且长度比`[t, i]`更小

> PS: 前缀和似乎很适合用于解决子数组之和的问题，因为它可以把问题转化为两个前缀和之差，是个常见技巧，需要积累一下

```cpp
class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        std::vector<long> pre(n + 1, 0);
        for (auto i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + nums[i];
        }

        std::deque<int> dq;
        int ans = INT_MAX;
        for (auto i = 0; i <= n; ++i) {
            long curr = pre[i];
            while (!dq.empty() && curr - pre[dq.front()] >= k) {
                ans = std::min(ans, i - dq.front());
                dq.pop_front();
            }
            while (!dq.empty() && curr < pre[dq.back()]) {
                dq.pop_back();
            }
            dq.push_back(i);
        }
        return ans == INT_MAX ? -1 : ans;
    }
};
```
